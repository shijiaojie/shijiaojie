<!DOCTYPE html><html lang="[&quot;zh-tw&quot;,&quot;en&quot;,&quot;default&quot;]"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content><meta name="keywords" content><meta name="author" content="shijiaojie,undefined"><meta name="copyright" content="shijiaojie"><title>【shijj】</title><link rel="stylesheet" href="/css/fan.css"><link rel="stylesheet" href="/css/thirdparty/jquery.mCustomScrollbar.min.css"><link rel="icon" href="/favicon.ico"><!-- script(src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML")--><script src="/js/mathjax/mathjax.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
    tex2jax: {inlineMath: [['$', '$'], ['\\(', '\\)']]}
});
</script><script>var isPassword = '' || false;
if (isPassword) {
    if (prompt('请输入文章密码') !== '') {
        alert('密码错误！');
        history.back();
    }
}</script><script>window.GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
}</script></head><body><canvas id="universe"></canvas><!--#body--><div id="sidebar"><div class="author-info"><div class="author-info-avatar"><img class="author-info-avatar-img" src="/avatar.png"></div><div class="author-info-name">shijiaojie</div><div class="author-info-description"></div><div class="links-buttons"><a class="links-button button-hover" href="https://github.com/fan-lv" target="_blank">GitHub<i class="icon-dot bg-color3"></i></a><a class="links-button button-hover" href="mailto:15757856604@163.com" target="_blank">E-Mail<i class="icon-dot bg-color10"></i></a><a class="links-button button-hover" href="tencent://message/?uin=1019593584&amp;Site=&amp;Menu=yes" target="_blank">QQ<i class="icon-dot bg-color2"></i></a></div><div class="author-info-articles"><a class="author-info-articles-archives article-meta" href="/archives"><span class="pull-top">日志</span><span class="pull-bottom">11</span></a><a class="author-info-articles-tags article-meta" href="/tags"><span class="pull-top">标签</span><span class="pull-bottom">9</span></a><a class="author-info-articles-categories article-meta" href="/categories"><span class="pull-top">分类</span><span class="pull-bottom">7</span></a></div></div></div><div id="main-container"><header><div id="menu-outer"><i class="menu-list-icon fas fa-bars"></i><nav id="menu-inner"><a class="menu-item" href="/">首页</a><a class="menu-item" href="/tags">标签</a><a class="menu-item" href="/categories">分类</a><a class="menu-item" href="/archives">归档</a><a class="menu-item" href="/about">关于</a></nav><div class="right-info"><a class="title-name" href="/">shijj</a><span id="now-time"></span></div></div></header><div id="content-outer"><div id="content-inner"><div id="recent-posts"><!-- each post in page.posts.sort('date', -1).limit(10).toArray()--><!-- config中配置按照什么排序--><div class="recent-post-item"><a class="post-title" href="/2019/05/22/02-数据库的备份和还原/">02-数据库的备份和还原</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2019-05-22</time><div class="button-hover categories"><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="/categories/数据库的备份和还原/">数据库的备份和还原</a></div><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/数据库的备份和还原/">数据库的备份和还原</a></div></div><div class="post-content"><div class="main-content content"><p>1.1数据库的备份和还原<br>1.1.1数据库的备份<br>1.1.1.1第一步：打开cmd的命令行窗口<br>mysqldump -u root -p web_test1 &gt;C:/web_test1.sql</p>
<p>1.1.2数据库的还原<br>1.1.2.1第一种还原方式：<br>第一步：在数据库服务器内部创建数据库：</p>
<p>第二步：在命令行窗口<br>mysql -u root -p web_test1 &lt; C:/web_test1.sql</p>
<p>1.1.2.2第二种还原方式<br>第一步：在数据库服务器内部创建数据库：</p>
<p>第二步：切换到该数据库使用source命令还原</p>
</div></div><a class="button-hover more" href="/2019/05/22/02-数据库的备份和还原/#more">阅读全文</a></div><div class="recent-post-item"><a class="post-title" href="/2019/05/22/01-重置MySQL密码笔记/">01-重置MySQL密码笔记</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2019-05-22</time><div class="button-hover categories"><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="/categories/重置MySQL的密码/">重置MySQL的密码</a></div><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/重置MySQL的密码/">重置MySQL的密码</a></div></div><div class="post-content"><div class="main-content content"><p>1.1重置MySQL的密码<br>1.1.1重置MySQL的密码步骤<br>1.1.1.1第一步：停止MySQL的服务</p>
<p>1.1.1.2第二步：在cmd下启动MySQL服务</p>
<p>1.1.1.3第三步：重新开启cmd的命令行<br>登录MySQL，不需要输入密码</p>
<p>1.1.1.4第四步：修改root的密码</p>
<p>1.1.1.5第五步：结束mysqld的进程</p>
<p>1.1.1.6第六步：重新启动MySQL的服务</p>
</div></div><a class="button-hover more" href="/2019/05/22/01-重置MySQL密码笔记/#more">阅读全文</a></div><div class="recent-post-item"><a class="post-title" href="/2019/05/22/MySQL单表/">MySQL单表</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2019-05-22</time><div class="button-hover categories"><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="/categories/MySQL单表/">MySQL单表</a></div><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/JAVA-MySQL单表/">JAVA--MySQL单表</a></div></div><div class="post-content"><div class="main-content content"><p>MySQL_day01<br>1.1MySQL的概述<br>1.1.1数据库的概述<br>1.1.1.1什么是数据库<br>数据库就是一个文件系统，通过标准的SQL语句获取数据<br>1.1.2MySQL的概述<br>1.1.2.1什么是MySQL数据库</p>
<p>1.1.3关系型数据库概述<br>1.1.3.1什么是关系型数据库<br>关系型数据库存放的是实体之间的关系</p>
<p>1.1.3.2常见的关系型数据库<br>MySQL<br>Oracle<br>SQLServer<br>DB2<br>SyBase<br>1.2MySQL的安装<br>1.2.1MySQL安装步骤<br>参见《MySQL的安装》视频<br>1.3MySQL的数据存储方式的概述<br>1.3.1服务器的概念<br>1.3.1.1什么是服务器<br>服务器要从硬件和软件两个方面来说：<br>硬件：指的就是一台计算机。<br>软件：需要在这台电脑上安装数据库服务器。<br>1.3.2MySQL数据库存储的方式<br>1.3.2.1存储方式的描述</p>
<p>一台数据库服务器中会创建很多数据库（一个项目，会创建一个数据库）。在数据库中会创建很多张表（一个实体会创建一个表）。在表中会有很多记录（一个对象的实例会添加一条新的记录）。<br>1.4SQL的概述<br>1.4.1SQL的概念<br>1.4.1.1什么是SQL</p>
<p>1.4.2SQL的分类<br>1.4.2.1DDL：数据定义语言<br>create，drop，alter..<br>1.4.2.2DCL：数据控制语言<br>grant，if…<br>1.4.2.3DML：数据操纵语言<br>insert，update，delete…<br>1.4.2.4DQL：数据查询语言<br>select<br>1.5使用SQL<br>1.5.1SQL对数据库进行操作<br>1.5.1.1创建数据库<br>语法：<br>create database 数据库名称 [character set 字符集 collate 字符集校对规则];</p>
<p>1.5.1.2查看数据库<br>语法：<br>查看数据库服务器中所有的数据库：show databases;</p>
<p>查看某个数据库的定义信息： show create database 数据库名称;</p>
<p>1.5.1.3修改数据库<br>语法：<br>alter database 数据库名称 character set 字符集 collate 校对规则;</p>
<p>1.5.1.4删除数据库<br>语法:<br>drop database 数据库名称;</p>
<p>1.5.1.5其他数据库操作<br>切换数据库：use 数据库名称;</p>
<p>查看当前正在使用的数据库：</p>
<p>1.5.2SQL对数据库表进行操作<br>1.5.2.1SQL创建表<br>语法：<br>create table 表名称(字段名称 字段类型(长度) 约束,字段名称 字段类型(长度) 约束…);<br>字段类型<br>一个实体对应一个表，一个实体属性对应表的一个字段。<br>Java中的类型                        MySQL中的类型<br>byte/short/int/long                     tinyint/smallint/int/bigint<br>float                                    float<br>double                                double<br>boolean                                bit<br>char/String                            char和varchar类型<br>                                    char和varchar的区别：</p>
<pre><code>* char代表是固定长度的字符或字符串。
    * 定义类型char(8),向这个字段存入字符串hello，那么数据库使用三个空格将其补全。
* varchar代表的是可变长度的字符串。
    * 定义类型varchar(8), 向这个字段存入字符串hello,那么存入到数据库的就是hello。
</code></pre><p>Date                                date/time/datetime/timestamp<br>                                    datetime和timestamp区别</p>
<pre><code>* datetime就是既有日期又有时间的日期类型，如果没有向这个字段中存值，数据库使用null存入到数据库中
* timestamp也是既有日期又有时间的日期类型，如果没有向这个字段中存值，数据库使用当前的系统时间存入到数据库中。
</code></pre><p>File                                    BLOB/TEXT<br>约束<br>约束作用：保证数据的完整性<br>单表约束分类：<br>主键约束：primary key 主键约束默认就是唯一 非空的<br>唯一约束：unique<br>非空约束：not null<br>建表语句：<br>create database web_test1;<br>use web_test1;<br>create table user(<br>    id int primary key auto_increment,<br>    username varchar(20) unique,<br>    password varchar(20) not null,<br>    age int,<br>    birthday date<br>);</p>
<p>1.5.2.2SQL查看表<br>查看某个数据库下的所有的表<br>语法：show tables;</p>
<p>查看某个表的结构信息<br>语法：desc 表名;</p>
<p>1.5.2.3SQL删除表<br>删除表<br>语法：drop table 表名;</p>
<p>1.5.2.4SQL修改表<br>修改表：添加列<br>alter table 表名 add 列名 类型(长度) 约束;</p>
<p>修改表：修改列类型，长度和约束<br>alter table 表名 modify 列名 类型(长度) 约束;</p>
<p>修改表：删除列<br>alter table 表名 drop 列名;</p>
<p>修改表：修改列名称<br>alter table 表名 change 旧列名 新列名 类型(长度) 约束;</p>
<p>修改表：修改表名<br>rename table 表名 to 新的表名;</p>
<p>修改表：修改表的字符集<br>alter table 表名 character set 字符集;</p>
<p>1.5.3SQL对数据库表的记录进行操作（重点）<br>1.5.3.1SQL添加表的记录<br>语法：<br>向表中插入某些列：insert into 表名 (列名1,列名2,列名3…) values (值1,值2,值3…)<br>向表中插入所有列：insert into 表名 values (值1,值2,值3…);<br>注意事项<br>1.值的类型与数据库中表列的类型一致。<br>2.值的顺序与数据库中表列的顺序一致。<br>3.值的最大长度不能超过列设置最大长度。<br>4.值的类型是字符串或者是日期类型，使用单引号引起来。<br>添加记录<br>添加某几列<br>insert into user (id,username,password) values (null,’aaa’,’123’);</p>
<p>添加所有列<br>insert into user values (null,’bbb’,’123’,23,’1993-09-01’);</p>
<p>添加中文记录<br>insert into user values (null,’张三’,’123’,23,’1993-09-01’);</p>
<p>直接向数据库中插入中文记录会出现错误！！！<br>解决方法：<br>    show variables like ‘%character%’;  –查看数据库中与字符集相关参数：<br>    需要将MySQL数据库服务器中的客户端部分的字符集改为gbk。<br>    找到MySQL的安装路径：my.ini文件，修改文件中[client]下的字符集</p>
<pre><code>* 重新启动MySQL的服务器
services.msc
</code></pre><p>1.5.3.2SQL修改表的记录<br>语法:<br>update 表名 set 列名=值,列名=值 [where 条件];<br>注意事项<br>1.值的类型与列的类型一致。<br>2.值的最大长度不能超过列设置的最大长度。<br>3.字符串类型和日期类型添加单引号。<br>修改某一列的所有值<br>update user set password = ‘abc’;</p>
<p>按条件修改数据<br>update user set password = ‘xyz’ where username = ‘bbb’;</p>
<p>按条件修改多个列<br>update user set password=’123’,age=34 where username=’aaa’;</p>
<p>1.5.3.3SQL删除表的记录<br>语法：<br>delete from 表名 [where 条件];<br>注意事项<br>1.删除表的记录，指的是删除表中的一行记录。<br>2.删除如果没有条件，默认是删除表中的所有记录。<br>删除某一条记录<br>delete from user where id = 2;</p>
<p>删除表中的所有记录<br>delete from user;</p>
<p>删除表中的记录有两种做法:<br>delete from user;<br>删除所有记录，属于DML语句，一条记录一条记录删除。事务可以作用在DML语句上的<br>truncate table user;<br>删除所有记录，属于DDL语句，将表删除，然后重新创建一个结构一样的表。事务不能控制DDL的<br>1.5.3.4SQL查看表的记录（重点）<br>基本查询<br>语法:select [distinct] *|列名 from 表 [条件];<br>环境的准备：<br>create table exam(<br>    id int primary key auto_increment,<br>    name varchar(20),<br>    english int,<br>    chinese int,<br>    math    int<br>);</p>
<p>insert into exam values (null,’张三’,85,74,91);<br>insert into exam values (null,’李四’,95,90,83);<br>insert into exam values (null,’王五’,85,84,59);<br>insert into exam values (null,’赵六’,75,79,76);<br>insert into exam values (null,’田七’,69,63,98);<br>insert into exam values (null,’李老八’,89,90,83);<br>查询所有学生考试成绩信息<br>select * from exam;</p>
<p>查询所有学生的姓名和英语成绩<br>select name,english from exam;</p>
<p>查询英语成绩信息（不显示重复的值）<br>select distinct english from exam;</p>
<p>查看学生姓名和学生的总成绩<br>select name,english+chinese+math from exam;</p>
<p>别名查询<br>select name,english+chinese+math as sum from exam;</p>
<p>条件查询<br>使用where子句<br>&gt; , &lt; , &gt;= , &lt;= , &lt;&gt; ,=<br>like:模糊查询<br>in:范围查询<br>条件关联:and , or ,not<br>查询李四学生的成绩：<br>select * from exam where name = ‘李四’;</p>
<p>查询名称叫李四学生并且英文大于90分<br>select * from exam where name = ‘李四’ and english &gt; 90;</p>
<p>查询姓李的学生的信息<br>like可以进行模糊查询,在like子句中可以使用<em>或者%作为占位符。</em>只能代表一个字符，而%可以代表任意个字符。</p>
<pre><code>* like ‘李_’        ：名字中必须是两个字，而且是姓李的。
* like ‘李%’        ：名字中姓李的学生，李子后可以是1个或任意个字符。
* like ‘%四’        ：名字中以四结尾的。
* like ‘%王%’    ：只要名称中包含这个字就可以。
</code></pre><p>select * from exam where name like ‘李%’;</p>
<p>查询英语成绩是69,75,89学生的信息<br>select * from exam where english in (69,75,89);</p>
<p>排序查询<br>使用order by 字段名称 asc/desc;<br>查询学生信息，并且按照语文成绩进行排序：<br>select * from exam order by chinese;</p>
<p>查询学生信息，并且按照语文成绩倒序排序：<br>select * from exam order by chinese desc;</p>
<p>查询学生信息，先按照语文成绩进行倒序排序，如果成绩相同再按照英语成绩升序排序<br>select * from exam order by chinese desc,english asc;</p>
<p>查询姓李的学生的信息，按照英语成绩降序排序<br>select * from exam where name like ‘李%’ order by english desc;</p>
<p>分组统计查询<br>聚合函数使用<br>sum();<br>获取所有学生的英语成绩的总和:<br>select sum(english) from exam;</p>
<p>获取所有学生的英语成绩和数学成绩总和：<br>select sum(english),sum(math) from exam;</p>
<p>查询姓李的学生的英语成绩的总和<br>select sum(english) from exam where name like ‘李%’;</p>
<p>查询所有学生各科的总成绩：<br>select sum(english)+sum(chinese)+sum(math) from exam;</p>
<p>select sum(english+chinese+math) from exam;<br>与上面的语句有什么不同？</p>
<ul>
<li>上面的语句是按照列的方式统计，英语成绩总和+语文成绩总和+数学成绩总和。</li>
<li>下面的语句先计算英语+数学+语文然后再求和。<ul>
<li>使用ifnull的函数</li>
</ul>
</li>
</ul>
<p>count();<br>获得学生的总数<br>select count(*) from exam;</p>
<p>获得姓李的学生的个数<br>select count(*) from exam where name like ‘李%’;</p>
<p>max();<br>获得数学成绩的最高分：<br>select max(math) from exam;</p>
<p>min();<br>获得语文成绩的最小值<br>select min(chinese) from exam;</p>
<p>avg();<br>获取语文成绩的平均值<br>select avg(chinese) from exam;</p>
<p>分组查询<br>语法：使用group by 字段名称;<br>环境准备<br>create table orderitem(<br>    id int primary key auto_increment,<br>    product varchar(20),<br>    price double<br>);<br>insert into orderitem values (null,’电视机’,2999);<br>insert into orderitem values (null,’电视机’,2999);<br>insert into orderitem values (null,’洗衣机’,1000);<br>insert into orderitem values (null,’洗衣机’,1000);<br>insert into orderitem values (null,’洗衣机’,1000);<br>insert into orderitem values (null,’冰箱’,3999);<br>insert into orderitem values (null,’冰箱’,3999);<br>insert into orderitem values (null,’空调’,1999);<br>按商品名称统计，每类商品所购买的个数：<br>select product,count(*) from orderitem group by product;</p>
<p>按商品名称统计，每类商品所花费的总金额：<br>select product,sum(price) from orderitem group by product;</p>
<p>按商品名称统计，统计每类商品花费的总金额在5000元以上的商品<br><strong>*</strong> where的子句后面不能跟着聚合函数。如果现在使用带有聚合函数的条件过滤（分组后条件过滤）需要使用一个关键字having<br>select product,sum(price) from orderitem  group by product having sum(price) &gt; 5000;</p>
<p>按商品名称统计，统计每类商品花费的总金额在5000元以上的商品，并且按照总金额升序排序<br>select product,sum(price) from orderitem  group by product having sum(price) &gt; 5000 order by sum(price) asc;</p>
<p>总结<br>S(select)… F(from)…W(where)…G(group by)…H(having)…O(order by);</p>
</div></div><a class="button-hover more" href="/2019/05/22/MySQL单表/#more">阅读全文</a></div><div class="recent-post-item"><a class="post-title" href="/2019/05/22/JAVA-XML/">JAVA--XML</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2019-05-22</time><div class="button-hover categories"><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="/categories/XML/">XML</a></div><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/JAVA-XML/">JAVA--XML</a></div></div><div class="post-content"><div class="main-content content"><p> java基础进阶xml<br>xml文件的概述与应用场景<br>xml文件的组成部分&amp;如何编写xml<br>xml的两种解析方式的原理<br><strong>**</strong> Dom4J开源工具的使用<br>第1章xml的概述与如何编写xml文件<br>1.1xml语言的概述<br>1.1.1xml介绍<br>xml语言是具有结构性的标记语言,  可以灵活的存储一对多的数据关系.</p>
<pre><code>举例:


以上这种数据, 如果通过我们学习的集合来存储的话, 需要通过多个集合的嵌套使用. 
那么很显然, 数据存储的过程就非常麻烦, 但是我们今天所学习的xml文件就可以很简单的存储这种一对多的数据
至于怎样存储, 我们稍后会详细讲解, 目前需要掌握的是关于xml的使用场景
    用来存储一对多的数据 

另外, xml还有一些其他的应用方面:

    之前学习过properties配置文件, 通过这种配置文件, 可以使代码的编写更加灵活.
    但是这种配置文件也只能存储一个键值对的映射关系, 如果需要存储多个呢?
    没错, 可以使用xml , 所以xml的另一方面应用就展示出来了

    用来当做配置文件存储数据
</code></pre><p>1.1.2问题: xml文件是用来做什么的?<br>核心思想：<br>        答：存储数据<br>            延伸问题： xml是怎样存储数据的？<br>                答：以标签的形式存储<br>                例:  <name>Jack</name><br>1.2xml的文档声明<br>1.2.1Xml文件的组成部分<br>文档声明<br>元素<br>元素的属性<br>注释<br>CDATA区<br>特殊字符<br>处理指令(PI:Processing Instruction)：了解</p>
<pre><code>绿色标注的内容：不作为掌握，了解即可
</code></pre><p>1.2.2文档声明<br>什么是文档声明?<br>    在编写XML文档时，需要先使用文档声明来声明XML文档。且必须出现在文档的第一行<br>    这就好比我们在写java文件的时候需要声明class一样, 就是个硬性的规定.</p>
<p>如何编写文档声明?<br>    &lt;?xml version=’1.0’ encoding=’UTF-8’?&gt;</p>
<pre><code>xml表示标签的名字
version表示当前文件的版本号
encoding表示当前编码, 需要跟文件的编码产生对应关系

ps: standalone表示标记此文档是否独立
    了解即可
</code></pre><p>1.3xml的元素<br>1.3.1什么是元素? 元素该如何编写?<br>1:     xml中的元素其实就是一个个的标签<br>    2:     标签分为两种</p>
<pre><code>a: 包含标签体
    理解: 尖括号全部成对儿出现, 所有的数据都用一对儿尖括号存储
    例:
        &lt;student&gt;
            &lt;name&gt;zhangsan&lt;/name&gt;
            &lt;age&gt;18&lt;/age&gt;
        &lt;/student&gt;

b: 不包含标签体
    理解: 只有最外层的一个尖括号,括号用/标识结束, 内部的数据都用属性来编写

        &lt;student 
            name=&quot;zhangsan&quot;
            age=&quot;18&quot;
        /&gt;

     两种方式都需要掌握, 但是第二种编写起来会更加方便
</code></pre><p>1.3.2标签(元素的书写规范)<br>严格区分大小写；</p><p></p><p><br>只能以字母或下划线开头；abc _abc<br>不能以xml(或XML、Xml等)开头—-W3C保留日后使用；<br>名称字符之间不能有空格或制表符；<br>名称字符之间不能使用冒号 : (有特殊用途)<br>1.3.3元素中属性的注意事项<br>           一个元素可以有多个属性，每个属性都有它自己的名称和取值。<br>            属性值一定要用引号(单引号或双引号)引起来。<br>            属性名称的命名规范与元素的命名规范相同<br>            元素中的属性是不允许重复的<br>            在XML技术中，标签属性所代表的信息也可以被改成用子元素的形式来描述<br>                例如：<br>&lt;?xml version=”1.0” encoding=”UTF-8”?&gt;</p>
<p><students><br>    <student name="zhangsan" age="18"></student></students></p>
<pre><code>&lt;student&gt;
    &lt;name&gt;zhangsan&lt;/name&gt;
    &lt;age&gt;18&lt;/age&gt;
&lt;/student&gt;
</code></pre><p><br>1.4xml的注释<br>1.4.1格式编写<br>格式:<br>    &lt;!—被注释的内容 – &gt;<br>1.4.2注意事项<br>注意: 注释不能嵌套定义<br>1.5xml的其他组成部分<br>1.5.1引入CDATA区<br>为什么要使用CDATA区域?</p>
<pre><code>如果我们在标签中写入的内容, 想要带有标签的标记符号的话, 就需要对这段内容进行转义
就好比java中的打印语句, 想要打印出”这个字符就必须用/进行转义.

标签也是一样, 想要将&lt;itheima&gt;当做内容存储的话, 就需要对他进行转义.
</code></pre><p>如何转义?</p>
<p>空格:&nbsp;<br>注意:<br>    这种转移可以达到效果, 但是如果操作的数据过多, 编写起来会非常痛苦, 所以, 可以使用CDATA区来解决此问题</p>
<p>1.5.2实例代码<br>&lt;?xml version=”1.0” encoding=”UTF-8”?&gt;<br><!-- 
    如果有一个包含标签体的标签，
    他的标签体是一个普通文本，不是子标签，
    而普通文本中包含了一个标签，那这样可以吗？
--></p>
<p><students><br>    <student><br>        <name>zhangsan</name><br>        <url><br>            &lt;![CDATA[<br>                <itheima><a href="http://www.itheima.com" target="_blank" rel="noopener">www.itheima.com</a></itheima><br>                <itcast><a href="http://www.itcast.cn" target="_blank" rel="noopener">www.itcast.cn</a></itcast><br>            ]]&gt;<br>        </url><br>    </student></students></p>
<pre><code>&lt;student&gt;
    &lt;name&gt;zhangsan&lt;/name&gt;
    &lt;url&gt;
        &amp;lt;itheima&amp;gt;www.itheima.com&amp;lt;/itheima&amp;gt;
    &lt;/url&gt;
&lt;/student&gt;
</code></pre><p><br>1.6DTD的入门案例<br>1.6.1为什么要有约束 (DTD)?<br>XML都是用户自定义的标签，若出现小小的错误，软件程序将不能正确地获取文件中的内容而报错。(如：Tomcat)<br>XML技术中，可以编写一个文档来约束一个XML的书写规范，这个文档称之为约束<br>1.6.2如何使用DTD约束文件?<br>1.编写DTD文件<br>&lt;?xml version=”1.0” encoding=”UTF-8”?&gt;<br>&lt;!ELEMENT 书架(书+)&gt;<br>    &lt;!ELEMENT 书 (书名,作者,售价)&gt;<br>    &lt;!ELEMENT 书名 (#PCDATA)&gt;<br>    &lt;!ELEMENT 作者 (#PCDATA)&gt;<br>    &lt;!ELEMENT 售价 (#PCDATA)&gt;<br>2.在xml文件中引入DTD文件<br>&lt;!DOCTYPE 书架 SYSTEM “book.dtd”&gt;<br>    引入了写好的DTD文件后, 格式就必须跟DTD文件保持一致<br>1.7DTD的细节<br>1.7.1语法细节<br>在DTD文档中使用ELEMENT关键字来声明一个XML元素。<br>•语法：&lt;!ELEMENT 元素名称 使用规则&gt;<br>使用规则：<br>•(#PCDATA):指示元素的主体内容只能是普通的文本.(Parsed Character Data)<br>•EMPTY：用于指示元素的主体为空。比如<br><br>•ANY:用于指示元素的主体内容为任意类型。<br>•(子元素)：指示元素中包含的子元素<br>•定义子元素及描述它们的关系:<br>–如果子元素用逗号分开，说明必须按照声明顺序去编写XML文档。<br>•如: &lt;!ELEMENT FILE (TITLE,AUTHOR,EMAIL)<br>–如果子元素用”|”分开，说明任选其一。<br>•如:&lt;!ELEMENT FILE (TITLE|AUTHOR|EMAIL)<br>–用+、<em>、？来表示元素出现的次数<br>•如果元素后面没有+</em>?:表示必须且只能出现一次<br>•+:表示至少出现一次，一次或多次<br>•*：表示可有可无，零次、一次或多次<br>•?:表示可以有也可以无，有的话只能有一次。零次或一次</p>
<p>1.7.2定义属性<br>•在DTD文档中使用ATTLIST关键字来为一个元素声明属性。<br>•语法：<br>        &lt;!ATTLIST 元素名<br>            属性名1 属性值类型 设置说明<br>            属性名2 属性值类型 设置说明<br>            …<br>        &gt;<br>•属性值类型：<br>–CDATA：表示属性的取值为普通的文本字符串<br>–ENUMERATED (DTD没有此关键字)：表示枚举，只能从枚举列表中任选其一，如(鸡肉|牛肉|猪肉|鱼肉)<br>–ID:表示属性的取值不能重复<br>•设置说明<br>–#REQUIRED：表示该属性必须出现<br>–#IMPLIED：表示该属性可有可无<br>–#FIXED:表示属性的取值为一个固定值。语法：#FIXED “固定值”<br>直接值：表示属性的取值为该默认值<br>1.7.3实例代码1<br>&lt;!ATTLIST 商品<br>        类别 CDATA #REQUIRED<br>        颜色 CDATA #IMPLIED</p>
<blockquote>
</blockquote>
<p>&lt;?xml version = “1.0” encoding=”GB2312” standalone=”yes”?&gt;<br>    &lt;商品 类别=”服装”颜色=”黄色” /&gt;<br>1.7.4实例代码2<br>&lt;?xml version = “1.0” encoding=”GB2312” standalone=”yes”?&gt;<br>&lt;!DOCTYPE 购物篮 [<br>   &lt;!ELEMENT 购物篮 (肉+)&gt;<br>    &lt;!ELEMENT 肉 EMPTY&gt;<br>    &lt;!ATTLIST 肉 品种 ( 鸡肉 | 牛肉 | 猪肉 | 鱼肉 ) “鸡肉”&gt;<br>]&gt;<br>&lt;购物篮&gt;<br>    &lt;肉 品种=”鱼肉”/&gt;<br>    &lt;肉 品种=”牛肉”/&gt;<br>    &lt;肉/&gt;<br>&lt;/购物篮&gt;</p>
<p>1.8Schema的概述<br>1.8.1概述<br>Schema约束自身就是一个XML文件，但它的扩展名通常为.xsd<br>一个XML Schema文档通常称之为模式文档(约束文档)，遵循这个文档书写的xml文件称之为实例文档。\<br>XML Schema对名称空间支持得非常好</p>
<p>理解:<br>    名称空间: 相当于package<br>约束文档: 编写好的Person类<br>    实例文档: 通过Person类创建对象<br>1.9Schema入门案例<br>1.9.1实例代码<br>约束文档:</p>
<p>&lt;?xml version=’1.0’ encoding=’UTF-8’ ?&gt;<br>&lt;xs:schema xmlns:xs=’<a href="http://www.w3.org/2001/XMLSchema&#39;" target="_blank" rel="noopener">http://www.w3.org/2001/XMLSchema&#39;</a><br>                     //标准的名称空间<br>                      targetNamespace=’<a href="http://www.itheima.com&#39;" target="_blank" rel="noopener">http://www.itheima.com&#39;</a><br>                        //将该schema文档绑定到<a href="http://www.itheima.com名称空间" target="_blank" rel="noopener">http://www.itheima.com名称空间</a><br>                &gt;<br>    &lt;xs:element name=’书架’ &gt;<br>        <a href="xs:complexType" target="_blank" rel="noopener">xs:complexType</a><br>            &lt;xs:sequence maxOccurs=’unbounded’ &gt;<br>                &lt;xs:element name=’书’ &gt;<br>                    <a href="xs:complexType" target="_blank" rel="noopener">xs:complexType</a><br>                        <a href="xs:sequence" target="_blank" rel="noopener">xs:sequence</a><br>                            &lt;xs:element name=’书名’ type=’xs:string’ /&gt;<br>                            &lt;xs:element name=’作者’ type=’xs:string’ /&gt;<br>                            &lt;xs:element name=’售价’ type=’xs:string’ /&gt;<br>                        &lt;/xs:sequence&gt;<br>                    &lt;/xs:complexType&gt;<br>                &lt;/xs:element&gt;<br>            &lt;/xs:sequence&gt;<br>        &lt;/xs:complexType&gt;<br>    &lt;/xs:element&gt;<br>&lt;/xs:schema&gt;</p>
<p>实例文档:<br>&lt;?xml version=”1.0” encoding=”UTF-8”?&gt;<br>&lt;itheima:书架 xmlns:itheima=”<a href="http://www.itheima.com&quot;" target="_blank" rel="noopener">http://www.itheima.com&quot;</a><br>                xmlns:xsi=”<a href="http://www.w3.org/2001/XMLSchema-instance&quot;" target="_blank" rel="noopener">http://www.w3.org/2001/XMLSchema-instance&quot;</a><br>                xsi:schemaLocation=”<a href="http://www.itheima.com" target="_blank" rel="noopener">http://www.itheima.com</a> book.xsd”&gt;<br>    <a href="itheima:书" target="_blank" rel="noopener">itheima:书</a><br>        <a href="itheima:书名" target="_blank" rel="noopener">itheima:书名</a>JavaScript网页开发&lt;/itheima:书名&gt;<br>        <a href="itheima:作者" target="_blank" rel="noopener">itheima:作者</a>张孝祥&lt;/itheima:作者&gt;<br>        <a href="itheima:售价" target="_blank" rel="noopener">itheima:售价</a>28.00元&lt;/itheima:售价&gt;<br>    &lt;/itheima:书&gt;<br>&lt;/itheima:书架&gt;</p>
<p>名称空间:<br>&lt;itheima:书架 xmlns:itheima=”<a href="http://www.itheima.com&quot;" target="_blank" rel="noopener">http://www.itheima.com&quot;</a><br>xmlns:xsi=”<a href="http://www.w3.org/2001/XMLSchema-instance&quot;" target="_blank" rel="noopener">http://www.w3.org/2001/XMLSchema-instance&quot;</a><br>xsi:schemaLocation=”<a href="http://www.itheima.com" target="_blank" rel="noopener">http://www.itheima.com</a> book.xsd”&gt;<br>1.9.2使用默认名称空间<br>•基本格式：<br>    xmlns=”URI”<br>•举例：<br>    &lt;书架 xmlns=”<a href="http://www.it315.org/xmlbook/schema&quot;" target="_blank" rel="noopener">http://www.it315.org/xmlbook/schema&quot;</a><br>        xmlns:xsi=”<a href="http://www.w3.org/2001/XMLSchema-instance&quot;" target="_blank" rel="noopener">http://www.w3.org/2001/XMLSchema-instance&quot;</a><br>        xsi:schemaLocation=”<a href="http://www.it315.org/xmlbook/schema" target="_blank" rel="noopener">http://www.it315.org/xmlbook/schema</a> book.xsd”&gt;<br>        &lt;书&gt;<br>        &lt;书名&gt;JavaScript网页开发&lt;/书名&gt;<br>        &lt;作者&gt;张孝祥&lt;/作者&gt;<br>        &lt;售价&gt;28.00元&lt;/售价&gt;<br>        &lt;/书&gt;<br>    &lt;书架&gt;</p>
<p>第2章解析xml文件<br>2.1XML解析的两种方式<br>2.1.1DOM方式和SAX方式<br>DOM：Document Object Model，文档对象模型。这种方式是W3C推荐的处理XML的一种方式。(全部加载完后再解析)<br>SAX：Simple API for XML。这种方式不是官方标准，属于开源社区XML-DEV，几乎所有的XML解析器都支持它。(边加载边解析)<br>XML解析开发包<br>JAXP：是SUN公司推出的解析标准实现。<br>Dom4J：是开源组织推出的解析开发包。(牛，大家都在用，包括SUN公司的一些技术的实现都在用。)<br>Dom for java four<br>Log4j<br>2.1.2总结:<br>DOM: 将整棵树一口气全部加载到内存当中, 我们可以非常方便的操作任意的标签和属性.<br>但是, 如果整棵树特别大的时候, 会出现内存溢出的问题</p>
<p>节点: 标签、属性、文本、甚至是换行都称之为节点</p>
<p>SAX: 一个节点一个节点的进行解析(暂不掌握)</p>
<p>2.2Dom4J的方法概述</p>
<ul>
<li>Dom4J的常用方法：<ul>
<li>Document</li>
<li>Element getRootElement() :获取根元素对象（根标签）</li>
<li>Element</li>
<li>List elements() ：获取所有的子元素</li>
<li>List elements(String name)：根据指定的元素名称来获取相应的所有的子元素</li>
<li>Element element(String name)：根据指定的元素名称来获取子元素对象,如果元素名称重复，则获取第一个元素 </li>
<li>String    elementText(String name) ：根据指定的子元素名称，来获取子元素中的文本</li>
<li>String    getText() ：获取当前元素对象的文本</li>
<li>void setText(String text)：设置当前元素对象的文本</li>
<li>String    attributeValue(String name)：根据指定的属性名称获取其对应的值</li>
<li>public Element addAttribute(String name,String value)：根据指定的属性名称和值进行添加或者修改BeanUtils的常用方法<br>2.3Dom4J的案例 (获取).<br>2.3.1功能分析<br>//1、得到某个具体的节点内容:打印”郑州”<br>//2、遍历所有元素节点:打印他们的元素名称。<br>Ps: 因为不知道有多少个元素节点, 所以需要递归.</li>
</ul>
</li>
</ul>
<p>2.3.2案例代码<br>private static void method2() throws Exception {<br>        //2、遍历所有元素节点:打印他们的元素名称。<br>        //获取根元素<br>        Document document = Dom4JUtils.getDocument();<br>        Element rootElement = document.getRootElement();<br>        treeWalk(rootElement);<br>    }</p>
<pre><code>public static void treeWalk(Element element) {
    //输出元素的名称
    System.out.println(element.getName());

    //获取指定元素的所有子元素
    List&lt;Element&gt; es = element.elements();
    for (Element e : es) {
        treeWalk(e);
    }
}

private static void method() throws Exception {
    //1、得到某个具体的节点内容:打印&quot;郑州&quot;
    Document document = Dom4JUtils.getDocument(); 
    //获取根元素
    Element rootElement = document.getRootElement();
    //获取根元素下的所有子元素
    List&lt;Element&gt; elements = rootElement.elements();
    //根据索引获取第一个City元素
    Element cityElement = elements.get(0);
    //根据子元素的名称来获取子元素的文本
    String text = cityElement.elementText(&quot;Name&quot;);
    System.out.println(text);
}
</code></pre><p>&lt;?xml version=”1.0” encoding=”UTF-8”?&gt;</p>
<state code="37" name="河南" description="郑州" gdp="99999亿"><br>  <city><br>    <name>郑州</name><br>    <region>高薪区</region><br>  </city><br>  <city>三门峡</city><br>  <city>洛阳</city><br>  <city>安阳</city><br>  <city>南阳</city><br></state>

<p>2.4Dom4J的案例(删除和修改)<br>2.4.1功能分析<br>//3、修改某个元素节点的主体内容:信阳–&gt;安阳<br>//6、删除指定元素节点:删除元素开封</p>
<pre><code>注意: 调用方法完毕, 仅仅是在内存中进行了修改, 需要用到OutputFormat和XMLWirter两个类配合使用
</code></pre><p>将数据写入到文件<br>2.4.2实例代码<br>public static void write2XML(Document document) throws IOException {<br>        OutputFormat format = OutputFormat.createPrettyPrint();<br>        //format.setEncoding(“UTF-8”);//默认的编码就是UTF-8<br>        XMLWriter writer = new XMLWriter( new FileOutputStream(“src/com/itheima_04/city.xml”), format );<br>        writer.write( document );<br>    }</p>
<p>private static void method3() throws Exception, IOException {<br>        //3、修改某个元素节点的主体内容:信阳–&gt;安阳<br>        Document document = Dom4JUtils.getDocument();<br>        //获取根元素<br>        Element rootElement = document.getRootElement();<br>        //获取根元素下的所有子元素<br>        List<element> es = rootElement.elements();<br>        //根据索引可以获取指定的元素<br>        Element cityElement = es.get(3);<br>        //修改文本<br>        cityElement.setText(“安阳”);<br>        //写回文件<br>        Dom4JUtils.write2XML(document);<br>    }</element></p>
<p>private static void method4() throws Exception, IOException {<br>        //6、删除指定元素节点:删除元素开封<br>        Document document = Dom4JUtils.getDocument();<br>        //获取根元素<br>        Element rootElement = document.getRootElement();<br>        //获取根元素下的所有子元素<br>        List<element> es = rootElement.elements();<br>        Element cityElement = es.get(1);<br>        //无法自杀，找他爹<br>        Element parentElement = cityElement.getParent();<br>        parentElement.remove(cityElement);<br>        //写回文件<br>        Dom4JUtils.write2XML(document);<br>    }</element></p>
<p>2.5Dom4J的案例(添加)<br>2.5.1功能分析<br>        //4、向指定元素节点中增加子元素节:添加一个新城市<city>南阳</city><br>        //5、向指定元素节点上增加同级元素节点:在洛阳前面，添加一个<city>三门峡</city><br>2.5.2案例代码<br>private static void method5() throws Exception, IOException {<br>        //4、向指定元素节点中增加子元素节:添加一个新城市<city>南阳</city><br>        Document document = Dom4JUtils.getDocument();<br>        //获取根元素<br>        Element rootElement = document.getRootElement();<br>        //添加元素<br>        Element cityElement = rootElement.addElement(“City”);<br>        //设置文本<br>        cityElement.setText(“南阳”);<br>        //写回文件<br>        Dom4JUtils.write2XML(document);<br>}</p>
<p>private static void method6() throws Exception, IOException {<br>        //5、向指定元素节点上增加同级元素节点:在洛阳前面，添加一个<city>三门峡</city><br>        //创建一个新的元素对象<br>        Element cityElement = DocumentHelper.createElement(“City”);<br>        //设置文本<br>        cityElement.setText(“三门峡”);</p>
<pre><code>Document document = Dom4JUtils.getDocument();
//获取根元素
Element rootElement = document.getRootElement();
//获取根元素下所有的子元素
List&lt;Element&gt; es = rootElement.elements();
//将新的元素添加到子元素列表中
es.add(1, cityElement);

//写会文件
Dom4JUtils.write2XML(document);
</code></pre><p>}<br>2.6Dom4J的案例（属性获取和添加）<br>2.6.1功能分析<br>        //7、操作XML文件属性:打印State的Name<br>        //8、添加属性：State： GDP=”99999亿”<br>2.6.2案例代码<br>private static void method7() throws Exception {<br>        //7、操作XML文件属性:打印State的Name<br>        Document document = Dom4JUtils.getDocument();<br>        //获取根元素<br>        Element rootElement = document.getRootElement();<br>        //根据属性名称获取值<br>        String value = rootElement.attributeValue(“Name”);<br>        System.out.println(value);<br>}</p>
<p>public static void main(String[] args) throws Exception  {<br>        //7、操作XML文件属性:打印State的Name<br>        //8、添加属性：State： GDP=”99999亿”<br>        Document document = Dom4JUtils.getDocument();<br>        //获取根元素<br>        Element rootElement = document.getRootElement();<br>        //添加新的属性和对应的值<br>        rootElement.addAttribute(“GDP”, “99999亿”);</p>
<pre><code>//写回文件
Dom4JUtils.write2XML(document);
</code></pre><p>}</p>
</div></div><a class="button-hover more" href="/2019/05/22/JAVA-XML/#more">阅读全文</a></div><div class="recent-post-item"><a class="post-title" href="/2019/05/22/网络编程/">网络编程</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2019-05-22</time><div class="button-hover categories"><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="/categories/网络编程/">网络编程</a></div><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/JAVA-网络编程/">JAVA--网络编程</a></div></div><div class="post-content"><div class="main-content content"><p>  面向网络编程<br> 网络编程概述<br> UDP<br> TCP<br>第1章网络编程概述<br>1.1网络协议<br>   通过计算机网络可以使多台计算机实现连接，位于同一个网络中的计算机在进行连接和通信时需要遵守一定的规则，这就好比在道路中行驶的汽车一定要遵守交通规则一样。在计算机网络中，这些连接和通信的规则被称为网络通信协议，它对数据的传输格式、传输速率、传输步骤等做了统一规定，通信双方必须同时遵守才能完成数据交换。<br>网络通信协议有很多种，目前应用最广泛的是TCP/IP协议(Transmission Control Protocal/Internet Protoal传输控制协议/英特网互联协议)，它是一个包括TCP协议和IP协议，UDP（User Datagram Protocol）协议和其它一些协议的协议组，在学习具体协议之前首先了解一下TCP/IP协议组的层次结构。<br>在进行数据传输时，要求发送的数据与收到的数据完全一样，这时，就需要在原有的数据上添加很多信息，以保证数据在传输过程中数据格式完全一致。TCP/IP协议的层次结构比较简单，共分为四层，如图所示。</p>
<p>图1-1TCP/IP网络模型<br>上图中，TCP/IP协议中的四层分别是应用层、传输层、网络层和链路层，每层分别负责不同的通信功能，接下来针对这四层进行详细地讲解。<br>链路层：链路层是用于定义物理传输通道，通常是对某些网络连接设备的驱动协议，例如针对光纤、网线提供的驱动。<br>网络层：网络层是整个TCP/IP协议的核心，它主要用于将传输的数据进行分组，将分组数据发送到目标计算机或者网络。<br>传输层：主要使网络程序进行通信，在进行网络通信时，可以采用TCP协议，也可以采用UDP协议。<br>应用层：主要负责应用程序的协议，例如HTTP协议、FTP协议等。</p>
<p>1.2IP地址和端口号<br>要想使网络中的计算机能够进行通信，必须为每台计算机指定一个标识号，通过这个标识号来指定接受数据的计算机或者发送数据的计算机。<br>在TCP/IP协议中，这个标识号就是IP地址，它可以唯一标识一台计算机，目前，IP地址广泛使用的版本是IPv4，它是由4个字节大小的二进制数来表示，如：00001010000000000000000000000001。由于二进制形式表示的IP地址非常不便记忆和处理，因此通常会将IP地址写成十进制的形式，每个字节用一个十进制数字(0-255)表示，数字间用符号“.”分开，如 “192.168.1.100”。<br>随着计算机网络规模的不断扩大，对IP地址的需求也越来越多，IPV4这种用4个字节表示的IP地址面临枯竭，因此IPv6 便应运而生了，IPv6使用16个字节表示IP地址，它所拥有的地址容量约是IPv4的8×1028倍，达到2128个（算上全零的），这样就解决了网络地址资源数量不够的问题。<br>通过IP地址可以连接到指定计算机，但如果想访问目标计算机中的某个应用程序，还需要指定端口号。在计算机中，不同的应用程序是通过端口号区分的。端口号是用两个字节（16位的二进制数）表示的，它的取值范围是0~65535，其中，0~1023之间的端口号用于一些知名的网络服务和应用，用户的普通应用程序需要使用1024以上的端口号，从而避免端口号被另外一个应用或服务所占用。<br>接下来通过一个图例来描述IP地址和端口号的作用，如下图所示。</p>
<p>从上图中可以清楚地看到，位于网络中一台计算机可以通过IP地址去访问另一台计算机，并通过端口号访问目标计算机中的某个应用程序。<br>1.3InetAddress<br>了解了IP地址的作用，我们看学习下JDK中提供了一个InetAdderss类，该类用于封装一个IP地址，并提供了一系列与IP地址相关的方法，下表中列出了InetAddress类的一些常用方法。</p>
<p>1.3.1案例代码一:<br>  package com.itheima_01;</p>
<p>import java.net.InetAddress;<br>import java.net.UnknownHostException;</p>
<p>/*</p>
<ul>
<li>InetAddress:此类表示互联网协议 (IP) 地址。 </li>
<li><p>*/<br>public class InetAddressDemo {<br> public static void main(String[] args) throws UnknownHostException   {</p>
<pre><code>//static InetAddress getByName(String host) 
 //InetAddress address = InetAddress.getByName(&quot;itheima&quot;);
InetAddress address = InetAddress.getByName(&quot;192.168.1.107&quot;);//ip地址是唯一的

//System.out.println(address);//itheima/192.168.1.107 ipconfig

String hostAddress = address.getHostAddress();//192.168.1.107 返回IP地址
String hostName = address.getHostName();//itheima    返回主机名

System.out.println(hostAddress);
System.out.println(hostName);
</code></pre></li>
</ul>
<pre><code>}
</code></pre><p>}</p>
<p>第2章UDP协议<br>   UDP是无连接通信协议，即在数据传输时，数据的发送端和接收端不建立逻辑连接。简单来说，当一台计算机向另外一台计算机发送数据时，发送端不会确认接收端是否存在，就会发出数据，同样接收端在收到数据时，也不会向发送端反馈是否收到数据。<br>由于使用UDP协议消耗资源小，通信效率高，所以通常都会用于音频、视频和普通数据的传输例如视频会议都使用UDP协议，因为这种情况即使偶尔丢失一两个数据包，也不会对接收结果产生太大影响。<br>但是在使用UDP协议传送数据时，由于UDP的面向无连接性，不能保证数据的完整性，因此在传输重要数据时不建议使用UDP协议。UDP的交换过程如下图所示。</p>
<p>2.1DatagramPacket<br>前面介绍了UDP是一种面向无连接的协议，因此，在通信时发送端和接收端不用建立连接。UDP通信的过程就像是货运公司在两个码头间发送货物一样。在码头发送和接收货物时都需要使用集装箱来装载货物，UDP通信也是一样，发送和接收的数据也需要使用“集装箱”进行打包，为此JDK中提供了一个DatagramPacket类，该类的实例对象就相当于一个集装箱，用于封装UDP通信中发送或者接收的数据。<br>想要创建一个DatagramPacket对象，首先需要了解一下它的构造方法。在创建发送端和接收端的DatagramPacket对象时，使用的构造方法有所不同，接收端的构造方法只需要接收一个字节数组来存放接收到的数据，而发送端的构造方法不但要接收存放了发送数据的字节数组，还需要指定发送端IP地址和端口号。<br>接下来根据API文档的内容，对DatagramPacket的构造方法进行逐一详细地讲解。</p>
<p>使用该构造方法在创建DatagramPacket对象时，指定了封装数据的字节数组和数据的大小，没有指定IP地址和端口号。很明显，这样的对象只能用于接收端，不能用于发送端。因为发送端一定要明确指出数据的目的地(ip地址和端口号)，而接收端不需要明确知道数据的来源，只需要接收到数据即可。</p>
<p>使用该构造方法在创建DatagramPacket对象时，不仅指定了封装数据的字节数组和数据的大小，还指定了数据包的目标IP地址（addr）和端口号（port）。该对象通常用于发送端，因为在发送数据时必须指定接收端的IP地址和端口号，就好像发送货物的集装箱上面必须标明接收人的地址一样。<br>上面我们讲解了DatagramPacket的构造方法，接下来对DatagramPacket类中的常用方法进行详细地讲解，如下表所示。</p>
<p>2.2DatagramSocket<br>DatagramPacket数据包的作用就如同是“集装箱”，可以将发送端或者接收端的数据封装起来。然而运输货物只有“集装箱”是不够的，还需要有码头。在程序中需要实现通信只有DatagramPacket数据包也同样不行，为此JDK中提供的一个DatagramSocket类。DatagramSocket类的作用就类似于码头，使用这个类的实例对象就可以发送和接收DatagramPacket数据包，发送数据的过程如下图所示。</p>
<p>在创建发送端和接收端的DatagramSocket对象时，使用的构造方法也有所不同，下面对DatagramSocket类中常用的构造方法进行讲解。</p>
<p>该构造方法用于创建发送端的DatagramSocket对象，在创建DatagramSocket对象时，并没有指定端口号，此时，系统会分配一个没有被其它网络程序所使用的端口号。</p>
<p>该构造方法既可用于创建接收端的DatagramSocket对象，又可以创建发送端的DatagramSocket对象，在创建接收端的DatagramSocket对象时，必须要指定一个端口号，这样就可以监听指定的端口。<br>上面我们讲解了DatagramSocket的构造方法，接下来对DatagramSocket类中的常用方法进行详细地讲解。</p>
<p>2.3UDP实现<br>2.3.1案例代码二:<br> package com.itheima_02;</p>
<p>import java.io.IOException;<br>import java.net.DatagramPacket;<br>import java.net.DatagramSocket;<br>import java.net.InetAddress;<br>import java.net.SocketException;</p>
<p>/*</p>
<ul>
<li>使用UDP协议发送数据<pre><code>创建发送端Socket对象
创建数据并打包
发送数据
释放资源
</code></pre></li>
<li></li>
<li>DatagramSocket:此类表示用来发送和接收数据,基于UDP协议的</li>
<li></li>
<li>DatagramSocket() ：创建Socket对象并随机分配端口号</li>
<li><p>DatagramSocket(int port) ：创建Socket对象并指定端口号<br>*/<br>public class SendDemo {<br> public static void main(String[] args) throws IOException  {</p>
<pre><code>//创建发送端Socket对象
DatagramSocket ds = new DatagramSocket();
//创建数据并打包
/*
 * DatagramPacket :此类表示数据报包
 * 数据 byte[]
 * 设备的地址 ip
 * 进程的地址  端口号
   DatagramPacket(byte[] buf, int length, InetAddress address, int port) 
 */

String s = &quot;hello udp,im comming!&quot;;
byte[] bys = s.getBytes();
int length = bys.length;
InetAddress address = InetAddress.getByName(&quot;itheima&quot;);//发送给当前设备
int port = 8888;
//打包
DatagramPacket dp = new DatagramPacket(bys,length,address,port);
//发送数据
ds.send(dp);
//释放资源
ds.close();
</code></pre><p> }<br>}</p>
</li>
</ul>
<p>package com.itheima_02;</p>
<p>import java.io.IOException;<br>import java.net.DatagramPacket;<br>import java.net.DatagramSocket;<br>import java.net.InetAddress;</p>
<p>/*</p>
<ul>
<li><p>使用UDP协议接收数据</p>
<pre><code>创建接收端Socket对象
接收数据
解析数据
输出数据
释放资源
</code></pre><p>*/<br>public class ReceiveDemo {<br> public static void main(String[] args) throws IOException {</p>
<pre><code>//创建接收端Socket对象
DatagramSocket ds = new DatagramSocket(8888);
//接收数据
//DatagramPacket(byte[] buf, int length) 
byte[] bys = new byte[1024];
DatagramPacket dp = new DatagramPacket(bys,bys.length);

System.out.println(1);
ds.receive(dp);//阻塞
System.out.println(2);

//解析数据
//InetAddress getAddress() : 获取发送端的IP对象
InetAddress address = dp.getAddress();
//byte[] getData()  ：获取接收到的数据，也可以直接使用创建包对象时的数组
byte[] data = dp.getData();
//int getLength()  ：获取具体收到数据的长度
int length = dp.getLength();
</code></pre></li>
</ul>
<pre><code>    //输出数据
    System.out.println(&quot;sender ---&gt; &quot; + address.getHostAddress());
    //System.out.println(new String(data,0,length));
    System.out.println(new String(bys,0,length));
    //释放资源
    ds.close();

}
</code></pre><p>}</p>
<p>第3章TCP协议<br>TCP通信同UDP通信一样，都能实现两台计算机之间的通信，通信的两端都需要创建socket对象。<br>区别在于，UDP中只有发送端和接收端，不区分客户端与服务器端，计算机之间可以任意地发送数据。<br>而TCP通信是严格区分客户端与服务器端的，在通信时，必须先由客户端去连接服务器端才能实现通信，服务器端不可以主动连接客户端，并且服务器端程序需要事先启动，等待客户端的连接。<br>在JDK中提供了两个类用于实现TCP程序，一个是ServerSocket类，用于表示服务器端，一个是Socket类，用于表示客户端。<br>通信时，首先创建代表服务器端的ServerSocket对象，该对象相当于开启一个服务，并等待客户端的连接，然后创建代表客户端的Socket对象向服务器端发出连接请求，服务器端响应请求，两者建立连接开始通信。<br>3.1ServerSocket<br>通过前面的学习知道，在开发TCP程序时，首先需要创建服务器端程序。JDK的java.net包中提供了一个ServerSocket类，该类的实例对象可以实现一个服务器段的程序。通过查阅API文档可知，ServerSocket类提供了多种构造方法，接下来就对ServerSocket的构造方法进行逐一地讲解。</p>
<p>使用该构造方法在创建ServerSocket对象时，就可以将其绑定到一个指定的端口号上（参数port就是端口号）。<br>接下来学习一下ServerSocket的常用方法，如表所示。</p>
<p>ServerSocket对象负责监听某台计算机的某个端口号，在创建ServerSocket对象后，需要继续调用该对象的accept()方法，接收来自客户端的请求。当执行了accept()方法之后，服务器端程序会发生阻塞，直到客户端发出连接请求，accept()方法才会返回一个Scoket对象用于和客户端实现通信，程序才能继续向下执行。<br>3.2Socket<br>讲解了ServerSocket对象可以实现服务端程序，但只实现服务器端程序还不能完成通信，此时还需要一个客户端程序与之交互，为此JDK提供了一个Socket类，用于实现TCP客户端程序。<br>通过查阅API文档可知Socket类同样提供了多种构造方法，接下来就对Socket的常用构造方法进行详细讲解。</p>
<p>使用该构造方法在创建Socket对象时，会根据参数去连接在指定地址和端口上运行的服务器程序，其中参数host接收的是一个字符串类型的IP地址。</p>
<p>该方法在使用上与第二个构造方法类似，参数address用于接收一个InetAddress类型的对象，该对象用于封装一个IP地址。<br>在以上Socket的构造方法中，最常用的是第一个构造方法。<br>接下来学习一下Socket的常用方法，如表所示。<br>方法声明    功能描述<br>int getPort()    该方法返回一个int类型对象，该对象是Socket对象与服务器端连接的端口号<br>InetAddress getLocalAddress()    该方法用于获取Socket对象绑定的本地IP地址，并将IP地址封装成InetAddress类型的对象返回<br>void close()    该方法用于关闭Socket连接，结束本次通信。在关闭socket之前，应将与socket相关的所有的输入/输出流全部关闭，这是因为一个良好的程序应该在执行完毕时释放所有的资源<br>InputStream getInputStream()    该方法返回一个InputStream类型的输入流对象，如果该对象是由服务器端的Socket返回，就用于读取客户端发送的数据，反之，用于读取服务器端发送的数据<br>OutputStream getOutputStream()    该方法返回一个OutputStream类型的输出流对象，如果该对象是由服务器端的Socket返回，就用于向客户端发送数据，反之，用于向服务器端发送数据<br>在Socket类的常用方法中，getInputStream()和getOutStream()方法分别用于获取输入流和输出流。当客户端和服务端建立连接后，数据是以IO流的形式进行交互的，从而实现通信。<br>接下来通过一张图来描述服务器端和客户端的数据传输，如下图所示。</p>
<p>3.3TCP协议实现<br>3.3.1案例代码三:<br>package com.itheima_04;</p>
<p>import java.io.IOException;<br>import java.io.OutputStream;<br>import java.net.InetAddress;<br>import java.net.Socket;</p>
<p>/*</p>
<ul>
<li><p>使用TCP协议发送数据</p>
<pre><code>创建发送端Socket对象（创建连接）
获取输出流对象
发送数据
释放资源
</code></pre><p> Socket(InetAddress address, int port)<br> Exception in thread “main” java.net.ConnectException: Connection refused: connect</p>
<p>*/<br>public class ClientDemo {<br> public static void main(String[] args) throws IOException {</p>
<pre><code>//创建发送端Socket对象（创建连接）
Socket s = new Socket(InetAddress.getByName(&quot;itheima&quot;),10086);
//获取输出流对象
OutputStream os = s.getOutputStream();
//发送数据
String str = &quot;hello tcp,im comming!!!&quot;;
os.write(str.getBytes());
//释放资源
//os.close();
s.close();
</code></pre><p> }<br>}</p>
</li>
</ul>
<p>package com.itheima_04;</p>
<p>import java.io.IOException;<br>import java.io.InputStream;<br>import java.net.InetAddress;<br>import java.net.ServerSocket;<br>import java.net.Socket;</p>
<p>/*</p>
<ul>
<li><p>使用TCP协议接收数据</p>
<pre><code>创建接收端Socket对象
监听（阻塞）
获取输入流对象
获取数据
输出数据
释放资源
</code></pre><p>  ServerSocket：接收端，服务端Socket<br>  ServerSocket(int port)<br>  Socket accept() </p>
<p>*/<br>public class ServerDemo {<br> public static void main(String[] args) throws IOException  {</p>
<pre><code>//创建接收端Socket对象
ServerSocket ss = new ServerSocket(10086);
 //监听（阻塞）
Socket s = ss.accept();
 //获取输入流对象
InputStream is = s.getInputStream();
 //获取数据
byte[] bys = new byte[1024];
int len;//用于存储读到的字节个数
len = is.read(bys);
 //输出数据
InetAddress address = s.getInetAddress();
System.out.println(&quot;client ---&gt; &quot; + address.getHostName());
System.out.println(new String(bys,0,len));
 //释放资源
s.close();
//ss.close();
</code></pre><p> }<br>}<br>3.4TCP相关案例<br>3.4.1案例代码四:<br>使用TCP协议发送数据，服务端将接收到的数据转换成大写返回给客户端</p>
</li>
</ul>
<p>package com.itheima_05;</p>
<p>import java.io.IOException;<br>import java.io.InputStream;<br>import java.io.OutputStream;<br>import java.net.InetAddress;<br>import java.net.Socket;</p>
<p>/*<br>     需求：使用TCP协议发送数据，并将接收到的数据转换成大写返回</p>
<pre><code>客户端发出数据
服务端接收数据
服务端转换数据
服务端发出数据
客户端接收数据
</code></pre><p> */<br>public class ClientDemo {<br>    public static void main(String[] args) throws IOException {<br>        //创建客户端Socket对象<br>        Socket s = new Socket(InetAddress.getByName(“itheima”),10010);<br>        //获取输出流对象<br>        OutputStream os = s.getOutputStream();<br>        //发出数据<br>        os.write(“tcp,im comming again!!!”.getBytes());</p>
<pre><code>    //获取输入流对象
    InputStream is = s.getInputStream();
    byte[] bys = new byte[1024];
    int len;//用于存储读取到的字节个数
    //接收数据
    len = is.read(bys);
    //输出数据
    System.out.println(new String(bys,0,len));

    //释放资源
    s.close();

}
</code></pre><p>}</p>
<p>package com.itheima_05;</p>
<p>import java.io.IOException;<br>import java.io.InputStream;<br>import java.io.OutputStream;<br>import java.net.ServerSocket;<br>import java.net.Socket;</p>
<p>public class ServerDemo {<br>    public static void main(String[] args) throws IOException {<br>        //创建服务端Socket对象<br>        ServerSocket ss = new ServerSocket(10010);<br>        //监听<br>        Socket s = ss.accept();<br>        //获取输入流对象<br>        InputStream is = s.getInputStream();<br>        //获取数据<br>        byte[] bys = new byte[1024];<br>        int len;//用于存储读取到的字节个数<br>        len = is.read(bys);<br>        String str = new String(bys,0,len);<br>        //输出数据<br>        System.out.println(str);<br>        //转换数据<br>        String upperStr = str.toUpperCase();<br>        //获取输出流对象<br>        OutputStream os = s.getOutputStream();<br>        //返回数据（发出数据）<br>        os.write(upperStr.getBytes());</p>
<pre><code>    //释放资源
    s.close();
    //ss.close();//服务端一般不关闭
}
</code></pre><p>}<br>3.4.2案例代码五:<br>  客户端:<br>1.提示用户输入用户名和密码,将用户输入的用户名和密码发送给服务端<br>2.接收服务端验证完用户名和密码的结果<br>  服务端:<br>1.接收客户端发送过来的用户名和密码<br>           2.如果用户名不是itheima或者 密码不是123456,就向客户端写入”登录失败”<br>             否则向客户端写入登录成功</p>
<p>package com.itheima_06;</p>
<p>import java.io.BufferedReader;<br>import java.io.IOException;<br>import java.io.InputStreamReader;<br>import java.io.PrintWriter;<br>import java.net.Socket;</p>
<p>/*</p>
<ul>
<li><p>模拟用户登录<br>*/<br>public class ClientTest {<br> public static void main(String[] args) throws  IOException  {</p>
<pre><code>//创建客户端Socket对象
//Socket s = new Socket(InetAddress.getByName(&quot;itheima&quot;),8888);
Socket s = new Socket(&quot;itheima&quot;,8888);

//获取用户名和密码
BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
System.out.println(&quot;请输入用户名:&quot;);
String username = br.readLine();
System.out.println(&quot;请输入密码:&quot;);
String password = br.readLine();
</code></pre></li>
</ul>
<pre><code>    //获取输出流对象
    //BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(s.getOutputStream()));
    PrintWriter out = new PrintWriter(s.getOutputStream(),true);
    //写出数据
    out.println(username);
    out.println(password);

    //获取输入流对象
    BufferedReader serverBr = new BufferedReader(new InputStreamReader(s.getInputStream()));
    //获取服务器返回的数据
    String result = serverBr.readLine();
    System.out.println(result);
    //释放资源
    s.close();
}
</code></pre><p>}</p>
<p>package com.itheima_06;</p>
<p>import java.io.BufferedReader;<br>import java.io.IOException;<br>import java.io.InputStreamReader;<br>import java.io.PrintWriter;<br>import java.net.ServerSocket;<br>import java.net.Socket;</p>
<p>public class ServerTest {<br>    public static void main(String[] args) throws IOException {<br>        //创建服务器端Socket对象<br>        ServerSocket ss = new ServerSocket(8888);<br>        //监听<br>        Socket s = ss.accept();<br>        //获取输入流对象<br>        BufferedReader br = new BufferedReader(new InputStreamReader(s.getInputStream()));<br>        //获取用户名和密码<br>        String username = br.readLine();<br>        String password = br.readLine();<br>        //判断用户名和密码是否正确<br>        boolean flag = false;<br>        if(“itheima”.equals(username) &amp;&amp; “123456”.equals(password)) {<br>            flag = true;<br>        }<br>        //获取输出流对象<br>        PrintWriter out = new PrintWriter(s.getOutputStream(),true);</p>
<pre><code>    //返回判断信息
    if(flag) {
        out.println(&quot;登陆成功&quot;);
    }
    else {
        out.println(&quot;登陆失败&quot;);
    }
    //释放资源
    s.close();
    //ss.close();//服务器一般不关闭
}
</code></pre><p>}</p>
<p>3.4.3案例代码六:<br> 将用户名和密码封装到一个User类中,提供对应的构造方法和getter/setter方法<br> 新建一个UserDB类里面定义一个集合,在集合中添加以下User对象<br>new User(“zhangsan”,”123456”);<br>         new User(“lisi”,”654321”);<br>         new User(“itheima”,”itheima”);<br>         new User(“admin”,”password”);<br> 客户端:<br>1.提示用户输入用户名和密码,将用户输入的用户名和密码发送给服务端<br>2.接收服务端验证完用户名和密码的结果</p>
<p> 服务端:<br>1.服务端将客户端发送过来的用户名密码封装成User对象<br>2.集合中如果包括这个User对象,想客户端写入” 登录成功”<br>否则向客户端写入”登录失败”</p>
<p>package com.itheima_07;</p>
<p>import java.io.BufferedReader;<br>import java.io.IOException;<br>import java.io.InputStreamReader;<br>import java.io.PrintWriter;<br>import java.net.Socket;</p>
<p>/*</p>
<ul>
<li><p>模拟用户登录改写（面向对象版本）<br>*/<br>public class ClientTest {<br> public static void main(String[] args) throws  IOException  {</p>
<pre><code>//创建客户端Socket对象
Socket s = new Socket(&quot;itheima&quot;,8888);

//获取用户名和密码
BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
System.out.println(&quot;请输入用户名:&quot;);
String username = br.readLine();
System.out.println(&quot;请输入密码:&quot;);
String password = br.readLine();
</code></pre></li>
</ul>
<pre><code>    //获取输出流对象
    PrintWriter out = new PrintWriter(s.getOutputStream(),true);
    //写出数据
    out.println(username);
    out.println(password);

    //获取输入流对象
    BufferedReader serverBr = new BufferedReader(new InputStreamReader(s.getInputStream()));
    //获取服务器返回的数据
    String result = serverBr.readLine();
    System.out.println(result);
    //释放资源
    s.close();
}
</code></pre><p>}</p>
<p>package com.itheima_07;</p>
<p>import java.io.BufferedReader;<br>import java.io.IOException;<br>import java.io.InputStreamReader;<br>import java.io.PrintWriter;<br>import java.net.ServerSocket;<br>import java.net.Socket;<br>import java.util.List;</p>
<p>public class ServerTest {<br>    public static void main(String[] args) throws IOException {<br>        //创建服务器端Socket对象<br>        ServerSocket ss = new ServerSocket(8888);<br>        //监听<br>        Socket s = ss.accept();<br>        //获取输入流对象<br>        BufferedReader br = new BufferedReader(new InputStreamReader(s.getInputStream()));<br>        //获取用户名和密码<br>        String username = br.readLine();<br>        String password = br.readLine();<br>        //判断用户名和密码是否正确<br>        boolean flag = false;</p>
<pre><code>    /*if(&quot;itheima&quot;.equals(username) &amp;&amp; &quot;123456&quot;.equals(password)) {
        flag = true;
    }*/

    List&lt;User&gt; users = UserDB.getUsers();
    User user = new User(username,password);
    if(users.contains(user)) {
        //匹配成功
        flag = true;
    }


    //获取输出流对象
    PrintWriter out = new PrintWriter(s.getOutputStream(),true);

    //返回判断信息
    if(flag) {
        out.println(&quot;登陆成功&quot;);
    }
    else {
        out.println(&quot;登陆失败&quot;);
    }
    //释放资源
    s.close();
    //ss.close();//服务器一般不关闭
}
</code></pre><p>}</p>
</div></div><a class="button-hover more" href="/2019/05/22/网络编程/#more">阅读全文</a></div><div class="recent-post-item"><a class="post-title" href="/2019/05/22/多线程/">多线程</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2019-05-22</time><div class="button-hover categories"><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="/categories/多线程/">多线程</a></div><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/JAVA-多线程/">JAVA--多线程</a></div></div><div class="post-content"><div class="main-content content"><p> 多线程<br> 多线程概述<br> 线程实现<br> 多线程安全问题产生 &amp; 解决方案<br>第1章 多线程概述<br>学习多线程之前，我们先要了解几个关于多线程有关的概念。<br>A:进程：进程指正在运行的程序。确切的来说，当一个程序进入内存运行，即变成一个进程，进程是处于运行过程中的程序，并且具有一定独立功能。<br>B:线程：线程是进程中的一个执行单元，负责当前进程中程序的执行，一个进程中至少有一个线程。一个进程中是可以有多个线程的，这个应用程序也可以称之为多线程程序。<br>C:简而言之：一个程序运行后至少有一个进程，一个进程中可以包含多个线程<br>什么是多线程呢？即就是一个程序中有多个线程在同时执行。<br>第2章线程实现</p>
<p>2.1实现线程一:继承Thread类<br>  该如何创建线程呢？通过API中搜索，查到Thread类。通过阅读Thread类中的描述。Thread是程序中的执行线程。Java 虚拟机允许应用程序并发地运行多个执行线程。</p>
<p>A:创建线程的步骤：<br>1.定义一个类继承Thread。<br>2.重写run方法。<br>3.创建子类对象，就是创建线程对象。<br>4.调用start方法，开启线程并让线程执行，同时还会告诉jvm去调用run方法<br>2.1.1案例代码一:<br>package com.itheima_01;</p>
<p>public class MyThread extends Thread {<br>    @Override<br>    public void run() {<br>        for (int i = 0; i &lt; 100; i++) {<br>            System.out.println(getName() + “:” + i);<br>        }<br>    }<br>}</p>
<p>package com.itheima_01;<br>/*</p>
<ul>
<li>多线程的实现方式：</li>
<li>方式1：一种方法是将类声明为 Thread 的子类。该子类应重写 Thread 类的 run 方法。接下来可以分配并启动该子类的实例</li>
<li></li>
<li>Thread</li>
<li>String getName()      返回该线程的名称。 </li>
<li>void   setName(String name) 改变线程名称，使之与参数 name 相同。</li>
<li></li>
<li></li>
<li><p>CPU执行程序的随机性<br>*/<br>public class ThreadDemo2 {<br> public static void main(String[] args) {</p>
<pre><code>//创建线程实例
MyThread mt = new MyThread();
//修改线程名字
mt.setName(&quot;张三&quot;);

//启动线程
mt.start();

//创建线程实例
MyThread mt2 = new MyThread();
mt2.setName(&quot;老王&quot;);

//启动线程
mt2.start();
</code></pre><p> }<br>}</p>
</li>
</ul>
<p>2.2实现线程二:实现Runnable接口<br>创建线程的另一种方法是声明实现 Runnable 接口的类。该类然后实现 run 方法。然后创建Runnable的子类对象，传入到某个线程的构造方法中，开启线程。<br>为何要实现Runnable接口，Runable是啥玩意呢？继续API搜索。<br>查看Runnable接口说明文档：Runnable接口用来指定每个线程要执行的任务。包含了一个 run 的无参数抽象方法，需要由接口实现类重写该方法。</p>
<p>创建线程的步骤。<br>1、定义类实现Runnable接口。<br>2、覆盖接口中的run方法。。<br>3、创建Thread类的对象<br>4、将Runnable接口的子类对象作为参数传递给Thread类的构造函数。<br>5、调用Thread类的start方法开启线程。<br>2.2.1案例代码二:<br>package com.itheima_02;</p>
<p>public class MyThread2 implements Runnable {<br>    int num;</p>
<pre><code>public MyThread2(int num) {
    this.num = num;
}

@Override
public void run() {
    for (int i = 0; i &lt; 100; i++) {
        //Thread t = Thread.currentThread();
        //System.out.println(t.getName() + &quot;:&quot; + i);

        //链式编程
        System.out.println(Thread.currentThread().getName() + &quot;:&quot; + i + num);
    }
}
</code></pre><p>}</p>
<p>第3章多线程安全问题产生&amp;解决方案<br>3.1多线程卖票案例<br>  需求:用三个线程模拟三个售票窗口,共同卖100张火车票,每个线程打印出卖第几张票<br>3.1.1  案例代码三:<br> package com.itheima_03;<br>public class TicketThread implements Runnable {<br>    int tickets = 100;//火车票数量</p>
<pre><code>@Override
public void run() {
    //出售火车票
    while(true) {
        //当火车票小于0张，则停止售票
        if(tickets &gt; 0) {
            /*
             * t1,t2,t3
             * 假设只剩一张票
             * t1过来了，他一看有票，他就进来了，但是他突然肚子不舒服，然后他就去上卫生间了
             * t2也过来了，他一看也有票，他也进来了，但是他的肚子也不舒服，他也去上卫生间了
             * 
             * t1上完了卫生间回来了，开始售票
             *     tickets = 0;
             * t2也上完卫生间回来了，他也进行售票
             *  tickets = -1;
             * 
             * 
             */
            try {
                Thread.sleep(100);
            } catch (InterruptedException e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
            }

            System.out.println(Thread.currentThread().getName() + &quot;:&quot; +tickets--);
        }
    }
}
</code></pre><p>}</p>
<p>3.2多线程安全问题解决<br>3.2.1使用同步代码块解决<br> 格式:<br>  synchronized(锁对象){<br>      //需要同步的代码<br>}</p>
<p>3.2.1.1案例代码四:<br>   package com.itheima_04;<br>/*</p>
<ul>
<li>问题出现的原因：</li>
<li>要有多个线程</li>
<li>要有被多个线程所共享的数据</li>
<li>多个线程并发的访问共享的数据</li>
<li></li>
<li>在火车上上厕所</li>
<li>张三来了，一看门是绿的，他就进去了，把门锁上了，门就变红了</li>
<li>李四来了，一看门市红色的，他就只能憋着</li>
<li>张三用完了厕所，把锁打开了，门就变成了绿色</li>
<li>李四一看门变绿了，他就进去了，把门锁上，门就变红了</li>
<li>王五来了，一看们是红色的，他也只能憋着</li>
<li>李四用完测试了，把锁打开了，肚子又不舒服了，扭头回去了，又把门锁上了，</li>
<li></li>
<li>synchronized:同步（锁），可以修饰代码块和方法，被修饰的代码块和方法一旦被某个线程访问，则直接锁住，其他的线程将无法访问</li>
<li></li>
<li>同步代码块：</li>
<li>synchronized(锁对象){</li>
<li></li>
<li>}</li>
<li></li>
<li>注意：锁对象需要被所有的线程所共享</li>
<li></li>
<li></li>
<li>同步：安全性高，效率低</li>
<li>非同步：效率高，但是安全性低</li>
<li><p>*/<br>public class TicketThread implements Runnable {<br> int tickets = 100;//火车票数量<br> Object obj = new Object();</p>
<p> @Override<br> public void run() {</p>
<pre><code>//出售火车票
while(true) {
    synchronized (obj) {

        if(tickets &gt; 0) {

            try {
                Thread.sleep(100);
            } catch (InterruptedException e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
            }

            System.out.println(Thread.currentThread().getName() + &quot;:&quot; +tickets--);
        }
    }

}
</code></pre><p> }</p>
</li>
</ul>
<p>}</p>
<p>package com.itheima_04;</p>
<p>public class TicktetTest {<br>    public static void main(String[] args) {<br>        //创建线程对象<br>        TicketThread tt = new TicketThread();</p>
<pre><code>    Thread t = new Thread(tt);
    t.setName(&quot;窗口1&quot;);
    Thread t2 = new Thread(tt);
    t2.setName(&quot;窗口2&quot;);
    Thread t3 = new Thread(tt);
    t3.setName(&quot;窗口3&quot;);

    //启动线程对象
    t.start();
    t2.start();
    t3.start();
}
</code></pre><p>}</p>
<p>3.2.2使用同步方法解决<br> 格式:<br>  修饰符 synchronized 返回值 方法名(){</p>
<p>}<br>3.2.2.1案例代码五:<br>package com.itheima_05;<br>/*</p>
<ul>
<li>同步方法:使用关键字synchronized修饰的方法，一旦被一个线程访问，则整个方法全部锁住，其他线程则无法访问</li>
<li></li>
<li>synchronized</li>
<li>注意：</li>
<li>非静态同步方法的锁对象是this</li>
<li><p>静态的同步方法的锁对象是当前类的字节码对象<br>*/<br>public class TicketThread implements Runnable {<br>static int tickets = 100;// 火车票数量<br>Object obj = new Object();</p>
<p>@Override<br>public void run() {<br>// 出售火车票<br>while (true) {<br> /*synchronized (obj) {</p>
<pre><code>method();
</code></pre><p> }*/</p>
<p> //method();<br> method2();</p>
<p>}<br>}</p>
<p>private synchronized void method() {<br>if (tickets &gt; 0) {</p>
<p> try {</p>
<pre><code>Thread.sleep(100);
</code></pre><p> } catch (InterruptedException e) {</p>
<pre><code>// TODO Auto-generated catch block
e.printStackTrace();
</code></pre><p> }</p>
<p> System.out.println(Thread.currentThread().getName() + “:” + tickets–);<br>}<br>}</p>
</li>
</ul>
<pre><code>private static synchronized void method2() {

    if (tickets &gt; 0) {

        try {
            Thread.sleep(100);
        } catch (InterruptedException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }

        System.out.println(Thread.currentThread().getName() + &quot;:&quot; + tickets--);
    }
}
</code></pre><p>}</p>
<p>package com.itheima_05;</p>
<p>public class TicktetTest {<br>    public static void main(String[] args) {<br>        //创建线程对象<br>        TicketThread tt = new TicketThread();</p>
<pre><code>    Thread t = new Thread(tt);
    t.setName(&quot;窗口1&quot;);
    Thread t2 = new Thread(tt);
    t2.setName(&quot;窗口2&quot;);
    Thread t3 = new Thread(tt);
    t3.setName(&quot;窗口3&quot;);

    //启动线程对象
    t.start();
    t2.start();
    t3.start();
}
</code></pre><p>}</p>
</div></div><a class="button-hover more" href="/2019/05/22/多线程/#more">阅读全文</a></div><div class="recent-post-item"><a class="post-title" href="/2019/05/19/反射/">JAVA - 反射</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2019-05-22</time><div class="button-hover categories"><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="/categories/JAVA/">JAVA</a></div><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/反射-JAVA/">反射 - JAVA</a></div></div><div class="post-content"><div class="main-content content"><p> java基础进阶<br>今日内容介绍<br>反射机制的概述和字节码对象的获取方式<br>反射操作构造方法、成员方法、成员属性<br>JavaBean的概述&amp;BeanUtils的使用<br>自定义BeanUtils工具类<br>第1章反射机制概述、字节码对象的获取方式、反射操作构造方法、成员方法、成员属性<br>1.1反射机制的概述和字节码对象的获取方式<br>1.1.1反射介绍<br>JAVA反射机制是在运行状态中,对于任意一个类,都能够知道这个类的所有属性和方法<br>        对于任意一个对象,都能够调用它的任意一个方法<br>        这种动态获取的以及动态调用对象的方法的功能称为java语言的反射机制.</p>
<p>  简单来说, 就可以把.class文件比做动物的尸体, 而反射技术就是对尸体的一种解剖.<br>  通过反射技术, 我们可以拿到该字节码文件中所有的东西, 例如成员变量, 成员方法, 构造方法, 而且还包括私有<br>1.1.2字节码文件获取的三种方式<br>1.对象名.getCalss();         // 次方法来自于Object  对象已经存在的情况下, 可以使用这种方式<br>2.类名.class            // 类名.class这是一个静态的属性, 只要知道类名, 就可以获取<br>3.Class.forName(“com.itheima_01.Student”);            // 通过Class类中的静态方法, 指定字符串, 该字符串是类的全类名(包名+类名)<br>// 此处将会抛出异常都系 ClassNotFoundException 防止传入错误的类名<br>1.1.3案例代码<br>package com.itheima_01;</p>
<p>/*</p>
<ul>
<li>反射：</li>
<li>在运行时，我们可以获取任意一个类的所有方法和属性</li>
<li>在运行时，让我们调用任意一个对象的所有方法和属性</li>
<li></li>
<li>反射的前提：</li>
<li><p>要获取类的对象（Class对象）<br><em>
</em>/<br>public class ReflectDemo {<br>public static void main(String[] args) throws ClassNotFoundException {<br>// 通过Object的getClass()方法获取，必须要有对象<br>Student s = new Student();<br>Class clazz = s.getClass();</p>
<p>// 通过类名获取字节码对象<br>Class clazz2 = Student.class;</p>
<p>// static Class&lt;?&gt; forName(String className)<br>Class clazz3 = Class.forName(“com.itheima_01.Student”);</p>
<p>System.out.println(clazz == clazz2);<br>System.out.println(clazz == clazz3);<br>System.out.println(clazz);</p>
<p>}<br>}<br>1.1.4问题: 字节码对象是用来描述什么的?<br>用来描述.class文件的.<br>面向对象阶段的时候讲过java中描述事物都是通过类的形式<br>而字节码文件也可以看做为一种事物, 如何描述这种事物? 那就看看这个事物是由什么组成的了</p>
<ol>
<li>成员变量</li>
<li>成员方法</li>
<li>构造方法<br>1.2反射操作构造方法<br>1.2.1通过获取的构造创建对象<br>步骤:<br>1.获得Class对象<br>2获得构造<br>3.通过构造对象获得实例化对象<br>package com.itheima_01;</li>
</ol>
</li>
</ul>
<p>import java.lang.reflect.Constructor;<br>import java.lang.reflect.InvocationTargetException;</p>
<p>/*</p>
<ul>
<li>通过反射获取构造方法并使用</li>
<li>Constructor&lt;?&gt;[] getConstructors()  </li>
<li>Constructor<t> getConstructor(Class&lt;?&gt;… parameterTypes) </t></li>
<li>T newInstance()<br><em>
</em>Constructor：</li>
<li><p>T newInstance(Object… initargs)<br>*/<br>public class ReflectDemo2 {<br>public static void main(String[] args) throws ReflectiveOperationException {<br>Class clazz = Class.forName(“com.itheima_01.Student”);</p>
<p>//method(clazz);<br>//Constructor<t> getConstructor(Class&lt;?&gt;… parameterTypes)<br>//method2(clazz);<br>//method3(clazz);</t></p>
<p>Object obj = clazz.newInstance();<br>System.out.println(obj);</p>
</li>
</ul>
<pre><code>}

private static void method3(Class clazz)
        throws NoSuchMethodException, InstantiationException, IllegalAccessException, InvocationTargetException {
    Constructor c = clazz.getConstructor(String.class,int.class);//获取有参构造，参数1类型为String，参数2类型为int
    System.out.println(c);
    Object obj = c.newInstance(&quot;lisi&quot;,30);
    System.out.println(obj);
}

private static void method2(Class clazz)
        throws NoSuchMethodException, InstantiationException, IllegalAccessException, InvocationTargetException {
    Constructor c = clazz.getConstructor();//获取无参构造
    System.out.println(c);
    Object obj = c.newInstance();
    System.out.println(obj);
}

private static void method(Class clazz) {
    //Constructor&lt;?&gt;[] getConstructors() :获取所有public修饰的构造方法 
    Constructor[] cs = clazz.getConstructors();
    for (int i = 0; i &lt; cs.length; i++) {
        System.out.println(cs[i]);
    }
}
</code></pre><p>}<br>1.2.2问题: 直接通过Class类中的newInstance()和获取getConstructor()有什么区别?<br>newInstance()方法, 只能通过空参的构造方法创建对象<br>getConstructor(Class<t>… parameterTypes)方法, 方法接受一个可变参数, 可以根据传入的类型来匹配对应的构造方法</t></p>
<p>总结<br>    Constructor&lt;?&gt;[] getConstructors()<br>                    Constructor<t> getConstructor(Class&lt;?&gt;… parameterTypes) </t></p>
<pre><code>方法1: 获取该类中所有的构造方法, 返回的是一个数组
方法2: 方法接受一个可变参数, 可以根据传入的类型, 来匹配对应的构造方法
</code></pre><p>1.3反射操作公共成员变量<br>1.3.1反射public成员变量(字段)<br>通过反射运行public变量流程</p>
<ol>
<li>通过反射获取该类的字节码对象<br>Class clazz = Class.forName(“com.heima.Person”);</li>
<li>创建该类对象<br>Object p = clazz.newInstance();</li>
<li>获取该类中需要操作的字段(成员变量)<br>getField(String name) –&gt; 方法传入字段的名称.<br>注意: 此方法只能获取公共的字段<br>Field f = clazz.getField(“age”);</li>
<li>通过字段对象中的方法修改属性值<br>void set(Object obj, Object value)  –&gt; 参数1): 要修改那个对象中的字段, 参数2): 将字段修改为什么值.<br>f.set(p, 23);<br>1.3.2案例代码<br>package com.itheima_01;</li>
</ol>
<p>import java.lang.reflect.Field;</p>
<p>/*</p>
<ul>
<li>通过反射获取成员变量并使用  </li>
<li>Field[] getFields()  </li>
<li>Field getField(String name)<br>*</li>
<li>Field[] getDeclaredFields()  </li>
<li>Field getDeclaredField(String name)<br>*</li>
<li>Field:</li>
<li>Object get(Object obj)  </li>
<li>void set(Object obj, Object value) </li>
</ul>
<p> */<br>public class ReflectDemo3 {<br>    public static void main(String[] args) throws ReflectiveOperationException {<br>        //获取学生类的字节码对象<br>        Class clazz = Class.forName(“com.itheima_01.Student”);<br>        //获取学生类的对象<br>        Object stu = clazz.newInstance();</p>
<pre><code>    //Field getField(String name)  :根据字段名称获取公共的字段对象
    Field f = clazz.getField(&quot;age&quot;);//获取成员变量对象
    //System.out.println(f);

    //void set(Object obj, Object value)
    f.set(stu,28);//通过成员变量对象，修改指定对为指定的值


    //Object get(Object obj)
    Object age = f.get(stu);//通过对象获取成员变量的值
    System.out.println(age);

    System.out.println(stu);


}

private static void method(Class clazz) {
    //Field[] getFields()  :获取公共的成员变量
    Field[] fs = clazz.getFields();
    for (int i = 0; i &lt; fs.length; i++) {
        System.out.println(fs[i]);
    }
    System.out.println(&quot;----------&quot;);
    //getDeclaredFields()  ：获取所有的成员变量
    Field[] fs2 = clazz.getDeclaredFields();
    for (int i = 0; i &lt; fs2.length; i++) {
        System.out.println(fs2[i]);
    }
}
</code></pre><p>}<br>1.3.3方法总结<br>             通过反射获取成员变量并使用<br>                     Field[] getFields()              –&gt; 返回该类所有(公共)的字段<br>                     Field getField(String name)      –&gt; 返回指定名称字段</p>
<pre><code>      Field[] getDeclaredFields()      --&gt; 暴力反射获取所有字段(包括私有) 
      Field getDeclaredField(String name) --&gt; 暴力反射获取指定名称字段

      ---------------马上讲-----------------

Field:
        Object get(Object obj)          --&gt; Field对象调用, 返回传入对象的具体字段
        void set(Object obj, Object value) --&gt;  Field对象调用
                                          参数1: 要修改的对象
                                          参数2: 将此对象的字段修改为什么值.
</code></pre><p>1.4反射操作私有成员变量<br>1.4.1反射private成员变量(字段)<br>反射private属性执行流程</p>
<ol>
<li>获取学生类字节码对象</li>
<li>获取学生对象</li>
<li>通过getDeclaredField方法获取私有字段</li>
<li>通过setAccessible让jvm不检查权限</li>
<li>通过set方法设置对象为具体的值<br>1.4.2案例代码<br>package com.itheima_01;</li>
</ol>
<p>import java.lang.reflect.Field;</p>
<p>/*</p>
<ul>
<li>通过反射获取私有成员变量并使用  </li>
<li>Field[] getDeclaredFields()  </li>
<li><p>Field getDeclaredField(String name)<br>*/<br>public class ReflectDemo4 {<br>public static void main(String[] args) throws ReflectiveOperationException {<br>//获取学生类的字节码对象<br>Class clazz = Class.forName(“com.itheima_01.Student”);<br>//获取学生对象<br>Object stu = clazz.newInstance();<br>//获取私有的字段对象<br>Field f = clazz.getDeclaredField(“name”);<br>f.setAccessible(true);//设置反射时取消Java的访问检查,暴力访问<br>//System.out.println(f);</p>
<p>f.set(stu, “lisi”);</p>
<p>Object name = f.get(stu);<br>System.out.println(name);<br>}</p>
</li>
</ul>
<p>}<br>1.4.3方法总结<br>               Field[] getDeclaredFields()      –&gt; 暴力反射获取所有字段(包括私有)<br>               Field getDeclaredField(String name) –&gt; 暴力反射获取指定名称字段<br>               void setAccessible(boolean flag) –&gt; 让jvm不检查权限<br>1.5通过反射获取成员方法并使用<br>1.5.1反射获取普通成员方法<br>反射public方法执行流程</p>
<ol>
<li>获取学生类字节码对象</li>
<li>反射手段创建学生对象</li>
<li>调用getMethod方法获取Method对象, 方法形参接受方法的名字</li>
<li>调用Method方法中的invoke()将方法运行<br>1.5.2案例代码<br>package com.itheima_01;</li>
</ol>
<p>import java.lang.reflect.InvocationTargetException;<br>import java.lang.reflect.Method;</p>
<p>/*</p>
<ul>
<li>通过反射获取成员方法并使用  </li>
<li>Method getMethod(String name, Class&lt;?&gt;… parameterTypes)  </li>
<li>Method:</li>
<li>Object invoke(Object obj, Object… args)  </li>
<li>*/</li>
</ul>
<p>public class ReflectDemo5 {<br>    public static void main(String[] args) throws ReflectiveOperationException {<br>        //获取学生类的字节码对象<br>        Class clazz = Class.forName(“com.itheima_01.Student”);<br>        //获取学生类的对象<br>        Object stu = clazz.newInstance();</p>
<pre><code>    //获取无参有返回值的方法
    Method m = clazz.getMethod(&quot;getName&quot;);
    Object obj = m.invoke(stu);
    System.out.println(obj);
}

private static void method2(Class clazz, Object stu)
        throws NoSuchMethodException, IllegalAccessException, InvocationTargetException {
    //获取有参无返回值的方法
    Method m = clazz.getMethod(&quot;setName&quot;, String.class);
    m.invoke(stu, &quot;lisi&quot;);
    System.out.println(stu);
}

private static void method(Class clazz, Object stu)
        throws NoSuchMethodException, IllegalAccessException, InvocationTargetException {
    //获取无参无返回值的方法
    Method m = clazz.getMethod(&quot;method&quot;);
    m.invoke(stu);
}
</code></pre><p>}<br>1.5.3方法总结<br>Class:<br>    Method getMethod(String name, Class&lt;?&gt;… parameterTypes)<br>            // 此方法由字节码对象调用<br>            // 参数1: 要反射的方法名称<br>            // 参数2: 此方法需要接受的参数类型(注意,传入的都是字节码)<br>Method:<br>    Object invoke(Object obj, Object… args)<br>            // 方法由Method对象调用<br>            // 参数1: 要由那个对象调用方法<br>            // 参数2: 方法需要的具体实参(实际参数)<br>1.5.4问题: 私有的成员方法怎么玩?</p>
<pre><code>// 获取字节码对象
Class clazz = Class.forName(&quot;com.heima.Student&quot;);
// 创建学生对象
Object stu = clazz.newInstance();
// 暴力反射获取方法
Method method = clazz.getDeclaredMethod(&quot;method&quot;);
// 让jvm不检查权限
method.setAccessible(true);
// 执行方法
method.invoke(stu);
</code></pre><p>第2章JavaBean的概述、BeanUtils的使用<br>2.1JavaBean的概述和规范<br>JavaBean的概述:<br>    将需要操作的多个属性封装成JavaBean, 简单来说就是用于封装数据的<br>规范：<br>类使用公共进行修饰<br>提供私有修饰的成员变量<br>为成员变量提供公共getter和setter方法<br>提供公共无参的构造<br>2.1.1实例代码<br>package com.itheima_02;</p>
<p>import java.io.Serializable;</p>
<p>/*</p>
<ul>
<li>JavaBean:用于封装数据</li>
<li>类使用公共进行修饰</li>
<li>提供私有修饰的成员变量</li>
<li>为成员变量提供公共getter和setter方法</li>
<li>提供公共无参的构造</li>
<li>实现序列号接口</li>
<li><p>*/<br>public class Person implements Serializable {</p>
<p> private static final long serialVersionUID = 1049712678750452511L;</p>
<p> private String name;<br> private int age;<br> private String gender;<br> public Person() {</p>
<pre><code>super();
// TODO Auto-generated constructor stub
</code></pre><p> }<br> public String getName() {</p>
<pre><code>return name;
</code></pre><p> }<br> public void setName(String name) {</p>
<pre><code>this.name = name;
</code></pre><p> }<br> public int getAge() {</p>
<pre><code>return age;
</code></pre><p> }<br> public void setAge(int age) {</p>
<pre><code>this.age = age;
</code></pre><p> }<br> public String getGender() {</p>
<pre><code>return gender;
</code></pre><p> }<br> public void setGender(String gender) {</p>
<pre><code>this.gender = gender;
</code></pre><p> }<br> @Override<br> public String toString() {</p>
<pre><code>return &quot;Person [name=&quot; + name + &quot;, age=&quot; + age + &quot;, gender=&quot; + gender + &quot;]&quot;;
</code></pre><p> }</p>
</li>
</ul>
<p>}</p>
<p>2.2BeanUtils的概述<br>BeanUtils的由来</p>
<pre><code>之前我们使用的类都是来自Java编写好的源代码
而这个BeanUtils却是一个叫做Apache的组织编写.
    那么这个组织编写的代码当中, 有一个系列可以很方便的提高我们今后的开发效率.
    这个系列为Commons, BeanUtils就是其中之一
</code></pre><p>2.2.1准备工作<br>1.导入两个jar包<br>commons-beanutils-1.8.3.jar<br>commons-logging-1.1.1.jar<br>2.将jar包Build path 配置到当前的classpath环境变量中<br>2.3BeanUtils的常用方法<br>static void    setProperty(Object bean, String name, Object value)<br>static String getProperty(Object bean, String name)<br>static void    populate(Object bean, Map properties) </p>
<pre><code>setProperty  用来给对象中的属性赋值(了解)
    参数1: 需要设置属性的对象
    参数2: 需要修改的属性名称
    参数3: 需要修改的具体元素    

getProperty 用来获取对象中的属性(了解)
    参数1: 要获取的javaBean对象
    参数2: 对象中的哪个属性

Populate 用来给对象中的属性赋值(掌握)

    参数1: 要设置属性的对象
    参数2: 将属性以Map集合的形式传入
                Key : 属性的名称
                Value:  属性具体的值
</code></pre><p>2.3.1实例代码<br>package com.itheima_02;</p>
<p>import java.lang.reflect.InvocationTargetException;<br>import java.util.HashMap;<br>import java.util.Map;</p>
<p>import org.apache.commons.beanutils.BeanUtils;</p>
<p>/*</p>
<ul>
<li>BeanUtils：Apache commons提供的一个组件，主要功能就是为了简化JavaBean封装数据的操作</li>
<li>static void    setProperty(Object bean, String name, Object value) </li>
<li>static String getProperty(Object bean, String name) </li>
<li>static void    populate(Object bean, Map properties) </li>
<li></li>
<li><p>注意：BeanUtils的setProperty和getProperty方法底层并不是直接操作成员变量，而是操作和成员变量名有关的get和set方法<br>*/<br>public class BeanUtilsDemo {<br> public static void main(String[] args) throws ReflectiveOperationException  {</p>
<pre><code>//static void    populate(Object bean, Map properties) 
Person p = new Person();

Map&lt;String,Object&gt; map = new HashMap&lt;String,Object&gt;();
map.put(&quot;name&quot;, &quot;lisi&quot;);
map.put(&quot;age&quot;, 18);
map.put(&quot;gender&quot;, &quot;male&quot;);

BeanUtils.populate(p,map);
System.out.println(p);
</code></pre><p> }</p>
<p> private static void method() throws IllegalAccessException, InvocationTargetException, NoSuchMethodException {</p>
<pre><code>Person p = new Person();
//System.out.println(p);

//static void    setProperty(Object bean, String name, Object value) ：给JavaBean对象的成员变量进行赋值
BeanUtils.setProperty(p, &quot;name&quot;, &quot;zhangsan&quot;);
//BeanUtils.setProperty(p, &quot;age&quot;, 18);
//System.out.println(p);

//static String getProperty(Object bean, String name) 
String name = BeanUtils.getProperty(p, &quot;name&quot;);
System.out.println(name);
</code></pre><p> }<br>}<br>2.3.2方法总结<br>三个方法底层是通过反射实现, 而且反射操作的是setXxx方法和getXxx方法.<br>所以编写JavaBean的时候一定要注意格式<br>2.4自定义BeanUtils的赋值和获取方法实现.<br>2.4.1功能分析<br>定义MyBeanUtils工具类, 实现与BeanUtils相同的功能</p>
</li>
</ul>
<p>public static void setProperty(Object bean,String name,Object value)<br>        // 设置任意对象的, 任意属性, 为任意的值<br>        public static String getProperty(Object bean,String name)<br>                // 获取任意对象的任意属性<br>            public static void populate(Object bean,Map map)<br>                    // 修改任意对象中的属性, 为传入Map集合中的键和值<br>                    Ps: 下个知识点<br>2.4.2实例代码<br>package com.itheima_03;</p>
<p>import java.lang.reflect.Field;</p>
<p>public class MyBeanUtils {<br>    private MyBeanUtils() {}</p>
<pre><code>//public static void setProperty(Object bean,String name,Object value)
public static void setProperty(Object bean,String name,Object value) throws ReflectiveOperationException {
    //根据JavaBean对象获取对应的字节码对象
    Class clazz = bean.getClass();
    //根据字节码对象获取对应的Field对象
    Field f = clazz.getDeclaredField(name);
    //设置权限，让虚拟机不进行访问的检查
    f.setAccessible(true);
    //赋值
    f.set(bean, value);
}
//public static String getProperty(Object bean,String name)
public static String getProperty(Object bean,String name) throws ReflectiveOperationException {
    Class clazz = bean.getClass();
    Field f = clazz.getDeclaredField(name);
    f.setAccessible(true);
    Object obj = f.get(bean);
    return obj.toString();
}
</code></pre><p>}<br>2.5自定义BeanUtils的populate方法实现<br>2.5.1功能分析<br>public static void populate(Object bean,Map map)<br>                // 修改任意对象中的属性, 为传入Map集合中的键和值<br>        思路:<br>1.获取传入对象的字节码对象<br>2.获取map集合中所有的键和值<br>3.调用Class中的getDeclaredField()方法将每一个键传入, 得到Field对象<br>4.通过Field对象中的set方法赋值<br>5.Try catch捕获getDeclaredField方法可能发生的异常.(为了方式传入错误的值)<br>2.5.2实例代码<br>    //public static void populate(Object bean,Map map)<br>    public static void populate(Object bean,Map map) throws ReflectiveOperationException {<br>        //通过JavaBean对象来获取对应的字节码对象<br>        Class clazz = bean.getClass();<br>        //获取Map中所有的key<br>        Set keys = map.keySet();<br>        for (Object key : keys) {</p>
<pre><code>        try {
            //根据key来获取对应的Field对象
            Field f = clazz.getDeclaredField(key.toString());
            //根据key来获取Map中对应的value
            Object value = map.get(key);

            f.setAccessible(true);
            f.set(bean, value);
        } catch(NoSuchFieldException e) {
            //e.printStackTrace();
        }
    }
}
</code></pre></div></div><a class="button-hover more" href="/2019/05/19/反射/#more">阅读全文</a></div><div class="recent-post-item"><a class="post-title" href="/2019/05/19/My-Gallary/">My Gallary</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2019-05-19</time></div><div class="post-content"><div class="main-content content"></div></div><a class="button-hover more" href="/2019/05/19/My-Gallary/#more">阅读全文</a></div><div class="recent-post-item"><a class="post-title" href="/2019/05/17/我的照片/">我的照片</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2019-05-17</time><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/风景/">风景</a></div></div><div class="post-content"><div class="main-content content"><p>随手拍的,不喜勿喷☺<br><img src="/2019/05/17/我的照片/bg.jpg" alt="加载失败"></p>
</div></div><a class="button-hover more" href="/2019/05/17/我的照片/#more">阅读全文</a></div><div class="recent-post-item"><a class="post-title" href="/2019/05/17/爱好/">爱好</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2019-05-17</time><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/爱好/">爱好</a></div></div><div class="post-content"><div class="main-content content"><p>打羽毛球,看书,看电影,爬山</p>
</div></div><a class="button-hover more" href="/2019/05/17/爱好/#more">阅读全文</a></div></div><div id="pagination"><div class="pagination"><span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fas fa-angle-right"></i></a></div></div></div></div><div class="button-hover" id="return-top"><i class="fas fa-arrow-up" aria-hidden="true"></i></div><footer><div id="footer"><div class="button-hover" id="side-button"><i class="fas fa-arrow-right"></i></div><div class="right-content"><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fas fa-user"></i></span><span id="busuanzi_value_site_uv"></span><span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fas fa-eye"></i></span><span id="busuanzi_value_site_pv"></span><span></span></div><div class="copyright">&copy;2017 ～ 2019 By shijiaojie</div></div></div></footer></div><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/thirdparty/jquery-3.3.1.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/thirdparty/velocity.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/thirdparty/jquery.mCustomScrollbar.concat.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/fan.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/canvas_bg.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/utils.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/scroll.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/sidebar.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/copy.js"></script><!--script(src=url)--></body></html>
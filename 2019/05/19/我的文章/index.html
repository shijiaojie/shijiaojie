<!DOCTYPE html><html lang="[&quot;zh-tw&quot;,&quot;en&quot;,&quot;default&quot;]"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="你對本頁的描述"><meta name="keywords" content="反射 - java"><meta name="author" content="shijiaojie,undefined"><meta name="copyright" content="shijiaojie"><title>JAVA - 反射【shijj】</title><link rel="stylesheet" href="/css/fan.css"><link rel="stylesheet" href="/css/thirdparty/jquery.mCustomScrollbar.min.css"><link rel="icon" href="/favicon.ico"><!-- script(src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML")--><script src="/js/mathjax/mathjax.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
    tex2jax: {inlineMath: [['$', '$'], ['\\(', '\\)']]}
});
</script><script>var isPassword = '' || false;
if (isPassword) {
    if (prompt('请输入文章密码') !== '') {
        alert('密码错误！');
        history.back();
    }
}</script><script>window.GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
}</script></head><body><canvas id="universe"></canvas><!--#body--><div id="sidebar"><div class="toggle-sidebar-info button-hover"><span data-toggle="文章目录">站点概览</span></div><div class="sidebar-toc"><div class="sidebar-toc-title">目录</div><div class="sidebar-toc-progress"><span class="progress-notice">您已阅读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc-progress-bar"></div></div><div class="sidebar-toc-content" id="sidebar-toc-content"></div></div><div class="author-info hide"><div class="author-info-avatar"><img class="author-info-avatar-img" src="/avatar.png"></div><div class="author-info-name">shijiaojie</div><div class="author-info-description"></div><div class="links-buttons"><a class="links-button button-hover" href="https://github.com/fan-lv" target="_blank">GitHub<i class="icon-dot bg-color7"></i></a><a class="links-button button-hover" href="mailto:15757856604@163.com" target="_blank">E-Mail<i class="icon-dot bg-color2"></i></a><a class="links-button button-hover" href="tencent://message/?uin=1019593584&amp;Site=&amp;Menu=yes" target="_blank">QQ<i class="icon-dot bg-color3"></i></a></div><div class="author-info-articles"><a class="author-info-articles-archives article-meta" href="/archives"><span class="pull-top">日志</span><span class="pull-bottom">5</span></a><a class="author-info-articles-tags article-meta" href="/tags"><span class="pull-top">标签</span><span class="pull-bottom">3</span></a><a class="author-info-articles-categories article-meta" href="/categories"><span class="pull-top">分类</span><span class="pull-bottom">1</span></a></div></div></div><div id="main-container"><header><div id="menu-outer"><i class="menu-list-icon fas fa-bars"></i><nav id="menu-inner"><a class="menu-item" href="/">首页</a><a class="menu-item" href="/tags">标签</a><a class="menu-item" href="/categories">分类</a><a class="menu-item" href="/archives">归档</a><a class="menu-item" href="/about">关于</a></nav><div class="right-info"><a class="title-name" href="/">shijj</a><span id="now-time"></span></div></div></header><div id="content-outer"><div id="content-inner"><article id="post"><div class="post-header"><div class="title">JAVA - 反射</div><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 发表于 2019-05-19 | 更新于 2019-05-19</time><!--time.button-hover.post-date #[i.fas.fa-calendar-alt.article-icon(aria-hidden="true")] #[=__('post.modified')] #[=date(page['updated'], config.date_format)]--><div class="button-hover categories"><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="/categories/JAVA-学习/">JAVA 学习</a></div><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/反射-java/">反射 - java</a></div></div></div><div class="main-content"><p> java基础进阶<br>今日内容介绍<br>反射机制的概述和字节码对象的获取方式<br>反射操作构造方法、成员方法、成员属性<br>JavaBean的概述&amp;BeanUtils的使用<br>自定义BeanUtils工具类<br>第1章反射机制概述、字节码对象的获取方式、反射操作构造方法、成员方法、成员属性<br>1.1反射机制的概述和字节码对象的获取方式<br>1.1.1反射介绍<br>JAVA反射机制是在运行状态中,对于任意一个类,都能够知道这个类的所有属性和方法<br>        对于任意一个对象,都能够调用它的任意一个方法<br>        这种动态获取的以及动态调用对象的方法的功能称为java语言的反射机制.</p>
<p>  简单来说, 就可以把.class文件比做动物的尸体, 而反射技术就是对尸体的一种解剖.<br>  通过反射技术, 我们可以拿到该字节码文件中所有的东西, 例如成员变量, 成员方法, 构造方法, 而且还包括私有<br>1.1.2字节码文件获取的三种方式<br>1.对象名.getCalss();         // 次方法来自于Object  对象已经存在的情况下, 可以使用这种方式<br>2.类名.class            // 类名.class这是一个静态的属性, 只要知道类名, 就可以获取<br>3.Class.forName(“com.itheima_01.Student”);            // 通过Class类中的静态方法, 指定字符串, 该字符串是类的全类名(包名+类名)<br>// 此处将会抛出异常都系 ClassNotFoundException 防止传入错误的类名<br>1.1.3案例代码<br>package com.itheima_01;</p>
<p>/*</p>
<ul>
<li>反射：</li>
<li>在运行时，我们可以获取任意一个类的所有方法和属性</li>
<li>在运行时，让我们调用任意一个对象的所有方法和属性</li>
<li></li>
<li>反射的前提：</li>
<li><p>要获取类的对象（Class对象）<br><em>
</em>/<br>public class ReflectDemo {<br>public static void main(String[] args) throws ClassNotFoundException {<br>// 通过Object的getClass()方法获取，必须要有对象<br>Student s = new Student();<br>Class clazz = s.getClass();</p>
<p>// 通过类名获取字节码对象<br>Class clazz2 = Student.class;</p>
<p>// static Class&lt;?&gt; forName(String className)<br>Class clazz3 = Class.forName(“com.itheima_01.Student”);</p>
<p>System.out.println(clazz == clazz2);<br>System.out.println(clazz == clazz3);<br>System.out.println(clazz);</p>
<p>}<br>}<br>1.1.4问题: 字节码对象是用来描述什么的?<br>用来描述.class文件的.<br>面向对象阶段的时候讲过java中描述事物都是通过类的形式<br>而字节码文件也可以看做为一种事物, 如何描述这种事物? 那就看看这个事物是由什么组成的了</p>
<ol>
<li>成员变量</li>
<li>成员方法</li>
<li>构造方法<br>1.2反射操作构造方法<br>1.2.1通过获取的构造创建对象<br>步骤:<br>1.获得Class对象<br>2获得构造<br>3.通过构造对象获得实例化对象<br>package com.itheima_01;</li>
</ol>
</li>
</ul>
<p>import java.lang.reflect.Constructor;<br>import java.lang.reflect.InvocationTargetException;</p>
<p>/*</p>
<ul>
<li>通过反射获取构造方法并使用</li>
<li>Constructor&lt;?&gt;[] getConstructors()  </li>
<li>Constructor<t> getConstructor(Class&lt;?&gt;… parameterTypes) </t></li>
<li>T newInstance()<br><em>
</em>Constructor：</li>
<li><p>T newInstance(Object… initargs)<br>*/<br>public class ReflectDemo2 {<br>public static void main(String[] args) throws ReflectiveOperationException {<br>Class clazz = Class.forName(“com.itheima_01.Student”);</p>
<p>//method(clazz);<br>//Constructor<t> getConstructor(Class&lt;?&gt;… parameterTypes)<br>//method2(clazz);<br>//method3(clazz);</t></p>
<p>Object obj = clazz.newInstance();<br>System.out.println(obj);</p>
</li>
</ul>
<pre><code>}

private static void method3(Class clazz)
        throws NoSuchMethodException, InstantiationException, IllegalAccessException, InvocationTargetException {
    Constructor c = clazz.getConstructor(String.class,int.class);//获取有参构造，参数1类型为String，参数2类型为int
    System.out.println(c);
    Object obj = c.newInstance(&quot;lisi&quot;,30);
    System.out.println(obj);
}

private static void method2(Class clazz)
        throws NoSuchMethodException, InstantiationException, IllegalAccessException, InvocationTargetException {
    Constructor c = clazz.getConstructor();//获取无参构造
    System.out.println(c);
    Object obj = c.newInstance();
    System.out.println(obj);
}

private static void method(Class clazz) {
    //Constructor&lt;?&gt;[] getConstructors() :获取所有public修饰的构造方法 
    Constructor[] cs = clazz.getConstructors();
    for (int i = 0; i &lt; cs.length; i++) {
        System.out.println(cs[i]);
    }
}
</code></pre><p>}<br>1.2.2问题: 直接通过Class类中的newInstance()和获取getConstructor()有什么区别?<br>newInstance()方法, 只能通过空参的构造方法创建对象<br>getConstructor(Class<t>… parameterTypes)方法, 方法接受一个可变参数, 可以根据传入的类型来匹配对应的构造方法</t></p>
<p>总结<br>    Constructor&lt;?&gt;[] getConstructors()<br>                    Constructor<t> getConstructor(Class&lt;?&gt;… parameterTypes) </t></p>
<pre><code>方法1: 获取该类中所有的构造方法, 返回的是一个数组
方法2: 方法接受一个可变参数, 可以根据传入的类型, 来匹配对应的构造方法
</code></pre><p>1.3反射操作公共成员变量<br>1.3.1反射public成员变量(字段)<br>通过反射运行public变量流程</p>
<ol>
<li>通过反射获取该类的字节码对象<br>Class clazz = Class.forName(“com.heima.Person”);</li>
<li>创建该类对象<br>Object p = clazz.newInstance();</li>
<li>获取该类中需要操作的字段(成员变量)<br>getField(String name) –&gt; 方法传入字段的名称.<br>注意: 此方法只能获取公共的字段<br>Field f = clazz.getField(“age”);</li>
<li>通过字段对象中的方法修改属性值<br>void set(Object obj, Object value)  –&gt; 参数1): 要修改那个对象中的字段, 参数2): 将字段修改为什么值.<br>f.set(p, 23);<br>1.3.2案例代码<br>package com.itheima_01;</li>
</ol>
<p>import java.lang.reflect.Field;</p>
<p>/*</p>
<ul>
<li>通过反射获取成员变量并使用  </li>
<li>Field[] getFields()  </li>
<li>Field getField(String name)<br>*</li>
<li>Field[] getDeclaredFields()  </li>
<li>Field getDeclaredField(String name)<br>*</li>
<li>Field:</li>
<li>Object get(Object obj)  </li>
<li>void set(Object obj, Object value) </li>
</ul>
<p> */<br>public class ReflectDemo3 {<br>    public static void main(String[] args) throws ReflectiveOperationException {<br>        //获取学生类的字节码对象<br>        Class clazz = Class.forName(“com.itheima_01.Student”);<br>        //获取学生类的对象<br>        Object stu = clazz.newInstance();</p>
<pre><code>    //Field getField(String name)  :根据字段名称获取公共的字段对象
    Field f = clazz.getField(&quot;age&quot;);//获取成员变量对象
    //System.out.println(f);

    //void set(Object obj, Object value)
    f.set(stu,28);//通过成员变量对象，修改指定对为指定的值


    //Object get(Object obj)
    Object age = f.get(stu);//通过对象获取成员变量的值
    System.out.println(age);

    System.out.println(stu);


}

private static void method(Class clazz) {
    //Field[] getFields()  :获取公共的成员变量
    Field[] fs = clazz.getFields();
    for (int i = 0; i &lt; fs.length; i++) {
        System.out.println(fs[i]);
    }
    System.out.println(&quot;----------&quot;);
    //getDeclaredFields()  ：获取所有的成员变量
    Field[] fs2 = clazz.getDeclaredFields();
    for (int i = 0; i &lt; fs2.length; i++) {
        System.out.println(fs2[i]);
    }
}
</code></pre><p>}<br>1.3.3方法总结<br>             通过反射获取成员变量并使用<br>                     Field[] getFields()              –&gt; 返回该类所有(公共)的字段<br>                     Field getField(String name)      –&gt; 返回指定名称字段</p>
<pre><code>      Field[] getDeclaredFields()      --&gt; 暴力反射获取所有字段(包括私有) 
      Field getDeclaredField(String name) --&gt; 暴力反射获取指定名称字段

      ---------------马上讲-----------------

Field:
        Object get(Object obj)          --&gt; Field对象调用, 返回传入对象的具体字段
        void set(Object obj, Object value) --&gt;  Field对象调用
                                          参数1: 要修改的对象
                                          参数2: 将此对象的字段修改为什么值.
</code></pre><p>1.4反射操作私有成员变量<br>1.4.1反射private成员变量(字段)<br>反射private属性执行流程</p>
<ol>
<li>获取学生类字节码对象</li>
<li>获取学生对象</li>
<li>通过getDeclaredField方法获取私有字段</li>
<li>通过setAccessible让jvm不检查权限</li>
<li>通过set方法设置对象为具体的值<br>1.4.2案例代码<br>package com.itheima_01;</li>
</ol>
<p>import java.lang.reflect.Field;</p>
<p>/*</p>
<ul>
<li>通过反射获取私有成员变量并使用  </li>
<li>Field[] getDeclaredFields()  </li>
<li><p>Field getDeclaredField(String name)<br>*/<br>public class ReflectDemo4 {<br>public static void main(String[] args) throws ReflectiveOperationException {<br>//获取学生类的字节码对象<br>Class clazz = Class.forName(“com.itheima_01.Student”);<br>//获取学生对象<br>Object stu = clazz.newInstance();<br>//获取私有的字段对象<br>Field f = clazz.getDeclaredField(“name”);<br>f.setAccessible(true);//设置反射时取消Java的访问检查,暴力访问<br>//System.out.println(f);</p>
<p>f.set(stu, “lisi”);</p>
<p>Object name = f.get(stu);<br>System.out.println(name);<br>}</p>
</li>
</ul>
<p>}<br>1.4.3方法总结<br>               Field[] getDeclaredFields()      –&gt; 暴力反射获取所有字段(包括私有)<br>               Field getDeclaredField(String name) –&gt; 暴力反射获取指定名称字段<br>               void setAccessible(boolean flag) –&gt; 让jvm不检查权限<br>1.5通过反射获取成员方法并使用<br>1.5.1反射获取普通成员方法<br>反射public方法执行流程</p>
<ol>
<li>获取学生类字节码对象</li>
<li>反射手段创建学生对象</li>
<li>调用getMethod方法获取Method对象, 方法形参接受方法的名字</li>
<li>调用Method方法中的invoke()将方法运行<br>1.5.2案例代码<br>package com.itheima_01;</li>
</ol>
<p>import java.lang.reflect.InvocationTargetException;<br>import java.lang.reflect.Method;</p>
<p>/*</p>
<ul>
<li>通过反射获取成员方法并使用  </li>
<li>Method getMethod(String name, Class&lt;?&gt;… parameterTypes)  </li>
<li>Method:</li>
<li>Object invoke(Object obj, Object… args)  </li>
<li>*/</li>
</ul>
<p>public class ReflectDemo5 {<br>    public static void main(String[] args) throws ReflectiveOperationException {<br>        //获取学生类的字节码对象<br>        Class clazz = Class.forName(“com.itheima_01.Student”);<br>        //获取学生类的对象<br>        Object stu = clazz.newInstance();</p>
<pre><code>    //获取无参有返回值的方法
    Method m = clazz.getMethod(&quot;getName&quot;);
    Object obj = m.invoke(stu);
    System.out.println(obj);
}

private static void method2(Class clazz, Object stu)
        throws NoSuchMethodException, IllegalAccessException, InvocationTargetException {
    //获取有参无返回值的方法
    Method m = clazz.getMethod(&quot;setName&quot;, String.class);
    m.invoke(stu, &quot;lisi&quot;);
    System.out.println(stu);
}

private static void method(Class clazz, Object stu)
        throws NoSuchMethodException, IllegalAccessException, InvocationTargetException {
    //获取无参无返回值的方法
    Method m = clazz.getMethod(&quot;method&quot;);
    m.invoke(stu);
}
</code></pre><p>}<br>1.5.3方法总结<br>Class:<br>    Method getMethod(String name, Class&lt;?&gt;… parameterTypes)<br>            // 此方法由字节码对象调用<br>            // 参数1: 要反射的方法名称<br>            // 参数2: 此方法需要接受的参数类型(注意,传入的都是字节码)<br>Method:<br>    Object invoke(Object obj, Object… args)<br>            // 方法由Method对象调用<br>            // 参数1: 要由那个对象调用方法<br>            // 参数2: 方法需要的具体实参(实际参数)<br>1.5.4问题: 私有的成员方法怎么玩?</p>
<pre><code>// 获取字节码对象
Class clazz = Class.forName(&quot;com.heima.Student&quot;);
// 创建学生对象
Object stu = clazz.newInstance();
// 暴力反射获取方法
Method method = clazz.getDeclaredMethod(&quot;method&quot;);
// 让jvm不检查权限
method.setAccessible(true);
// 执行方法
method.invoke(stu);
</code></pre><p>第2章JavaBean的概述、BeanUtils的使用<br>2.1JavaBean的概述和规范<br>JavaBean的概述:<br>    将需要操作的多个属性封装成JavaBean, 简单来说就是用于封装数据的<br>规范：<br>类使用公共进行修饰<br>提供私有修饰的成员变量<br>为成员变量提供公共getter和setter方法<br>提供公共无参的构造<br>2.1.1实例代码<br>package com.itheima_02;</p>
<p>import java.io.Serializable;</p>
<p>/*</p>
<ul>
<li>JavaBean:用于封装数据</li>
<li>类使用公共进行修饰</li>
<li>提供私有修饰的成员变量</li>
<li>为成员变量提供公共getter和setter方法</li>
<li>提供公共无参的构造</li>
<li>实现序列号接口</li>
<li><p>*/<br>public class Person implements Serializable {</p>
<p> private static final long serialVersionUID = 1049712678750452511L;</p>
<p> private String name;<br> private int age;<br> private String gender;<br> public Person() {</p>
<pre><code>super();
// TODO Auto-generated constructor stub
</code></pre><p> }<br> public String getName() {</p>
<pre><code>return name;
</code></pre><p> }<br> public void setName(String name) {</p>
<pre><code>this.name = name;
</code></pre><p> }<br> public int getAge() {</p>
<pre><code>return age;
</code></pre><p> }<br> public void setAge(int age) {</p>
<pre><code>this.age = age;
</code></pre><p> }<br> public String getGender() {</p>
<pre><code>return gender;
</code></pre><p> }<br> public void setGender(String gender) {</p>
<pre><code>this.gender = gender;
</code></pre><p> }<br> @Override<br> public String toString() {</p>
<pre><code>return &quot;Person [name=&quot; + name + &quot;, age=&quot; + age + &quot;, gender=&quot; + gender + &quot;]&quot;;
</code></pre><p> }</p>
</li>
</ul>
<p>}</p>
<p>2.2BeanUtils的概述<br>BeanUtils的由来</p>
<pre><code>之前我们使用的类都是来自Java编写好的源代码
而这个BeanUtils却是一个叫做Apache的组织编写.
    那么这个组织编写的代码当中, 有一个系列可以很方便的提高我们今后的开发效率.
    这个系列为Commons, BeanUtils就是其中之一
</code></pre><p>2.2.1准备工作<br>1.导入两个jar包<br>commons-beanutils-1.8.3.jar<br>commons-logging-1.1.1.jar<br>2.将jar包Build path 配置到当前的classpath环境变量中<br>2.3BeanUtils的常用方法<br>static void    setProperty(Object bean, String name, Object value)<br>static String getProperty(Object bean, String name)<br>static void    populate(Object bean, Map properties) </p>
<pre><code>setProperty  用来给对象中的属性赋值(了解)
    参数1: 需要设置属性的对象
    参数2: 需要修改的属性名称
    参数3: 需要修改的具体元素    

getProperty 用来获取对象中的属性(了解)
    参数1: 要获取的javaBean对象
    参数2: 对象中的哪个属性

Populate 用来给对象中的属性赋值(掌握)

    参数1: 要设置属性的对象
    参数2: 将属性以Map集合的形式传入
                Key : 属性的名称
                Value:  属性具体的值
</code></pre><p>2.3.1实例代码<br>package com.itheima_02;</p>
<p>import java.lang.reflect.InvocationTargetException;<br>import java.util.HashMap;<br>import java.util.Map;</p>
<p>import org.apache.commons.beanutils.BeanUtils;</p>
<p>/*</p>
<ul>
<li>BeanUtils：Apache commons提供的一个组件，主要功能就是为了简化JavaBean封装数据的操作</li>
<li>static void    setProperty(Object bean, String name, Object value) </li>
<li>static String getProperty(Object bean, String name) </li>
<li>static void    populate(Object bean, Map properties) </li>
<li></li>
<li><p>注意：BeanUtils的setProperty和getProperty方法底层并不是直接操作成员变量，而是操作和成员变量名有关的get和set方法<br>*/<br>public class BeanUtilsDemo {<br> public static void main(String[] args) throws ReflectiveOperationException  {</p>
<pre><code>//static void    populate(Object bean, Map properties) 
Person p = new Person();

Map&lt;String,Object&gt; map = new HashMap&lt;String,Object&gt;();
map.put(&quot;name&quot;, &quot;lisi&quot;);
map.put(&quot;age&quot;, 18);
map.put(&quot;gender&quot;, &quot;male&quot;);

BeanUtils.populate(p,map);
System.out.println(p);
</code></pre><p> }</p>
<p> private static void method() throws IllegalAccessException, InvocationTargetException, NoSuchMethodException {</p>
<pre><code>Person p = new Person();
//System.out.println(p);

//static void    setProperty(Object bean, String name, Object value) ：给JavaBean对象的成员变量进行赋值
BeanUtils.setProperty(p, &quot;name&quot;, &quot;zhangsan&quot;);
//BeanUtils.setProperty(p, &quot;age&quot;, 18);
//System.out.println(p);

//static String getProperty(Object bean, String name) 
String name = BeanUtils.getProperty(p, &quot;name&quot;);
System.out.println(name);
</code></pre><p> }<br>}<br>2.3.2方法总结<br>三个方法底层是通过反射实现, 而且反射操作的是setXxx方法和getXxx方法.<br>所以编写JavaBean的时候一定要注意格式<br>2.4自定义BeanUtils的赋值和获取方法实现.<br>2.4.1功能分析<br>定义MyBeanUtils工具类, 实现与BeanUtils相同的功能</p>
</li>
</ul>
<p>public static void setProperty(Object bean,String name,Object value)<br>        // 设置任意对象的, 任意属性, 为任意的值<br>        public static String getProperty(Object bean,String name)<br>                // 获取任意对象的任意属性<br>            public static void populate(Object bean,Map map)<br>                    // 修改任意对象中的属性, 为传入Map集合中的键和值<br>                    Ps: 下个知识点<br>2.4.2实例代码<br>package com.itheima_03;</p>
<p>import java.lang.reflect.Field;</p>
<p>public class MyBeanUtils {<br>    private MyBeanUtils() {}</p>
<pre><code>//public static void setProperty(Object bean,String name,Object value)
public static void setProperty(Object bean,String name,Object value) throws ReflectiveOperationException {
    //根据JavaBean对象获取对应的字节码对象
    Class clazz = bean.getClass();
    //根据字节码对象获取对应的Field对象
    Field f = clazz.getDeclaredField(name);
    //设置权限，让虚拟机不进行访问的检查
    f.setAccessible(true);
    //赋值
    f.set(bean, value);
}
//public static String getProperty(Object bean,String name)
public static String getProperty(Object bean,String name) throws ReflectiveOperationException {
    Class clazz = bean.getClass();
    Field f = clazz.getDeclaredField(name);
    f.setAccessible(true);
    Object obj = f.get(bean);
    return obj.toString();
}
</code></pre><p>}<br>2.5自定义BeanUtils的populate方法实现<br>2.5.1功能分析<br>public static void populate(Object bean,Map map)<br>                // 修改任意对象中的属性, 为传入Map集合中的键和值<br>        思路:<br>1.获取传入对象的字节码对象<br>2.获取map集合中所有的键和值<br>3.调用Class中的getDeclaredField()方法将每一个键传入, 得到Field对象<br>4.通过Field对象中的set方法赋值<br>5.Try catch捕获getDeclaredField方法可能发生的异常.(为了方式传入错误的值)<br>2.5.2实例代码<br>    //public static void populate(Object bean,Map map)<br>    public static void populate(Object bean,Map map) throws ReflectiveOperationException {<br>        //通过JavaBean对象来获取对应的字节码对象<br>        Class clazz = bean.getClass();<br>        //获取Map中所有的key<br>        Set keys = map.keySet();<br>        for (Object key : keys) {</p>
<pre><code>        try {
            //根据key来获取对应的Field对象
            Field f = clazz.getDeclaredField(key.toString());
            //根据key来获取Map中对应的value
            Object value = map.get(key);

            f.setAccessible(true);
            f.set(bean, value);
        } catch(NoSuchFieldException e) {
            //e.printStackTrace();
        }
    }
}
</code></pre></div><div class="post-copyright"><div class="post-copyright-author"><span class="post-copyright-meta">本文作者: </span><span class="post-copyright-info"><a href="mailto:undefined">shijiaojie</a></span></div><div class="post-copyright-type"><span class="post-copyright-meta">本文链接: </span><span class="post-copyright-info"><a href="http://yoursite.com/2019/05/19/我的文章/">http://yoursite.com/2019/05/19/我的文章/</a></span></div><div class="post-copyright-notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://yoursite.com">shijj</a>！</span></div></div></article><div id="pagination"><div class="next-post pull-right"><span class="line line-top"></span><span class="line line-right"></span><span class="line line-bottom"></span><span class="line line-left"></span><a href="/2019/05/19/My-Gallary/"><span>My Gallary</span><span>&nbsp;</span><i class="fas fa-angle-right"></i></a></div></div><!--div!= paginator()--></div></div><div class="button-hover" id="return-top"><i class="fas fa-arrow-up" aria-hidden="true"></i></div><footer><div id="footer"><div class="button-hover" id="side-button"><i class="fas fa-arrow-right"></i></div><div class="right-content"><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fas fa-file-o"></i></span><span id="busuanzi_value_page_pv"></span><span></span></div><div class="copyright">&copy;2017 ～ 2019 By shijiaojie</div></div></div></footer></div><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/thirdparty/jquery-3.3.1.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/thirdparty/velocity.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/thirdparty/jquery.mCustomScrollbar.concat.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/fan.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/canvas_bg.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/utils.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/scroll.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/sidebar.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/copy.js"></script><!--script(src=url)--></body></html>
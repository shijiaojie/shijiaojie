<!DOCTYPE html><html lang="[&quot;zh-tw&quot;,&quot;en&quot;,&quot;default&quot;]"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="多线程"><meta name="keywords" content="JAVA--多线程"><meta name="author" content="shijiaojie,undefined"><meta name="copyright" content="shijiaojie"><title>多线程【shijj】</title><link rel="stylesheet" href="/css/fan.css"><link rel="stylesheet" href="/css/thirdparty/jquery.mCustomScrollbar.min.css"><link rel="icon" href="/favicon.ico"><!-- script(src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML")--><script src="/js/mathjax/mathjax.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
    tex2jax: {inlineMath: [['$', '$'], ['\\(', '\\)']]}
});
</script><script>var isPassword = '' || false;
if (isPassword) {
    if (prompt('请输入文章密码') !== '') {
        alert('密码错误！');
        history.back();
    }
}</script><script>window.GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
}</script></head><body><canvas id="universe"></canvas><!--#body--><div id="sidebar"><div class="toggle-sidebar-info button-hover"><span data-toggle="文章目录">站点概览</span></div><div class="sidebar-toc"><div class="sidebar-toc-title">目录</div><div class="sidebar-toc-progress"><span class="progress-notice">您已阅读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc-progress-bar"></div></div><div class="sidebar-toc-content" id="sidebar-toc-content"></div></div><div class="author-info hide"><div class="author-info-avatar"><img class="author-info-avatar-img" src="/avatar.png"></div><div class="author-info-name">shijiaojie</div><div class="author-info-description"></div><div class="links-buttons"><a class="links-button button-hover" href="https://github.com/fan-lv" target="_blank">GitHub<i class="icon-dot bg-color1"></i></a><a class="links-button button-hover" href="mailto:15757856604@163.com" target="_blank">E-Mail<i class="icon-dot bg-color7"></i></a><a class="links-button button-hover" href="tencent://message/?uin=1019593584&amp;Site=&amp;Menu=yes" target="_blank">QQ<i class="icon-dot bg-color3"></i></a></div><div class="author-info-articles"><a class="author-info-articles-archives article-meta" href="/archives"><span class="pull-top">日志</span><span class="pull-bottom">6</span></a><a class="author-info-articles-tags article-meta" href="/tags"><span class="pull-top">标签</span><span class="pull-bottom">4</span></a><a class="author-info-articles-categories article-meta" href="/categories"><span class="pull-top">分类</span><span class="pull-bottom">1</span></a></div></div></div><div id="main-container"><header><div id="menu-outer"><i class="menu-list-icon fas fa-bars"></i><nav id="menu-inner"><a class="menu-item" href="/">首页</a><a class="menu-item" href="/tags">标签</a><a class="menu-item" href="/categories">分类</a><a class="menu-item" href="/archives">归档</a><a class="menu-item" href="/about">关于</a></nav><div class="right-info"><a class="title-name" href="/">shijj</a><span id="now-time"></span></div></div></header><div id="content-outer"><div id="content-inner"><article id="post"><div class="post-header"><div class="title">多线程</div><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 发表于 2019-05-22 | 更新于 2019-05-22</time><!--time.button-hover.post-date #[i.fas.fa-calendar-alt.article-icon(aria-hidden="true")] #[=__('post.modified')] #[=date(page['updated'], config.date_format)]--><div class="button-hover categories"></div><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/JAVA-多线程/">JAVA--多线程</a></div></div></div><div class="main-content"><p>  多线程<br>今日内容介绍<br> 多线程概述<br> 线程实现<br> 多线程安全问题产生 &amp; 解决方案<br>第1章 多线程概述<br>学习多线程之前，我们先要了解几个关于多线程有关的概念。<br>A:进程：进程指正在运行的程序。确切的来说，当一个程序进入内存运行，即变成一个进程，进程是处于运行过程中的程序，并且具有一定独立功能。<br>B:线程：线程是进程中的一个执行单元，负责当前进程中程序的执行，一个进程中至少有一个线程。一个进程中是可以有多个线程的，这个应用程序也可以称之为多线程程序。<br>C:简而言之：一个程序运行后至少有一个进程，一个进程中可以包含多个线程<br>什么是多线程呢？即就是一个程序中有多个线程在同时执行。<br>第2章线程实现</p>
<p>2.1实现线程一:继承Thread类<br>  该如何创建线程呢？通过API中搜索，查到Thread类。通过阅读Thread类中的描述。Thread是程序中的执行线程。Java 虚拟机允许应用程序并发地运行多个执行线程。</p>
<p>A:创建线程的步骤：<br>1.定义一个类继承Thread。<br>2.重写run方法。<br>3.创建子类对象，就是创建线程对象。<br>4.调用start方法，开启线程并让线程执行，同时还会告诉jvm去调用run方法<br>2.1.1案例代码一:<br>package com.itheima_01;</p>
<p>public class MyThread extends Thread {<br>    @Override<br>    public void run() {<br>        for (int i = 0; i &lt; 100; i++) {<br>            System.out.println(getName() + “:” + i);<br>        }<br>    }<br>}</p>
<p>package com.itheima_01;<br>/*</p>
<ul>
<li>多线程的实现方式：</li>
<li>方式1：一种方法是将类声明为 Thread 的子类。该子类应重写 Thread 类的 run 方法。接下来可以分配并启动该子类的实例</li>
<li></li>
<li>Thread</li>
<li>String getName()      返回该线程的名称。 </li>
<li>void   setName(String name) 改变线程名称，使之与参数 name 相同。</li>
<li></li>
<li></li>
<li><p>CPU执行程序的随机性<br>*/<br>public class ThreadDemo2 {<br> public static void main(String[] args) {</p>
<pre><code>//创建线程实例
MyThread mt = new MyThread();
//修改线程名字
mt.setName(&quot;张三&quot;);

//启动线程
mt.start();

//创建线程实例
MyThread mt2 = new MyThread();
mt2.setName(&quot;老王&quot;);

//启动线程
mt2.start();
</code></pre><p> }<br>}</p>
</li>
</ul>
<p>2.2实现线程二:实现Runnable接口<br>创建线程的另一种方法是声明实现 Runnable 接口的类。该类然后实现 run 方法。然后创建Runnable的子类对象，传入到某个线程的构造方法中，开启线程。<br>为何要实现Runnable接口，Runable是啥玩意呢？继续API搜索。<br>查看Runnable接口说明文档：Runnable接口用来指定每个线程要执行的任务。包含了一个 run 的无参数抽象方法，需要由接口实现类重写该方法。</p>
<p>创建线程的步骤。<br>1、定义类实现Runnable接口。<br>2、覆盖接口中的run方法。。<br>3、创建Thread类的对象<br>4、将Runnable接口的子类对象作为参数传递给Thread类的构造函数。<br>5、调用Thread类的start方法开启线程。<br>2.2.1案例代码二:<br>package com.itheima_02;</p>
<p>public class MyThread2 implements Runnable {<br>    int num;</p>
<pre><code>public MyThread2(int num) {
    this.num = num;
}

@Override
public void run() {
    for (int i = 0; i &lt; 100; i++) {
        //Thread t = Thread.currentThread();
        //System.out.println(t.getName() + &quot;:&quot; + i);

        //链式编程
        System.out.println(Thread.currentThread().getName() + &quot;:&quot; + i + num);
    }
}
</code></pre><p>}</p>
<p>第3章多线程安全问题产生&amp;解决方案<br>3.1多线程卖票案例<br>  需求:用三个线程模拟三个售票窗口,共同卖100张火车票,每个线程打印出卖第几张票<br>3.1.1  案例代码三:<br> package com.itheima_03;<br>public class TicketThread implements Runnable {<br>    int tickets = 100;//火车票数量</p>
<pre><code>@Override
public void run() {
    //出售火车票
    while(true) {
        //当火车票小于0张，则停止售票
        if(tickets &gt; 0) {
            /*
             * t1,t2,t3
             * 假设只剩一张票
             * t1过来了，他一看有票，他就进来了，但是他突然肚子不舒服，然后他就去上卫生间了
             * t2也过来了，他一看也有票，他也进来了，但是他的肚子也不舒服，他也去上卫生间了
             * 
             * t1上完了卫生间回来了，开始售票
             *     tickets = 0;
             * t2也上完卫生间回来了，他也进行售票
             *  tickets = -1;
             * 
             * 
             */
            try {
                Thread.sleep(100);
            } catch (InterruptedException e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
            }

            System.out.println(Thread.currentThread().getName() + &quot;:&quot; +tickets--);
        }
    }
}
</code></pre><p>}</p>
<p>3.2多线程安全问题解决<br>3.2.1使用同步代码块解决<br> 格式:<br>  synchronized(锁对象){<br>      //需要同步的代码<br>}</p>
<p>3.2.1.1案例代码四:<br>   package com.itheima_04;<br>/*</p>
<ul>
<li>问题出现的原因：</li>
<li>要有多个线程</li>
<li>要有被多个线程所共享的数据</li>
<li>多个线程并发的访问共享的数据</li>
<li></li>
<li>在火车上上厕所</li>
<li>张三来了，一看门是绿的，他就进去了，把门锁上了，门就变红了</li>
<li>李四来了，一看门市红色的，他就只能憋着</li>
<li>张三用完了厕所，把锁打开了，门就变成了绿色</li>
<li>李四一看门变绿了，他就进去了，把门锁上，门就变红了</li>
<li>王五来了，一看们是红色的，他也只能憋着</li>
<li>李四用完测试了，把锁打开了，肚子又不舒服了，扭头回去了，又把门锁上了，</li>
<li></li>
<li>synchronized:同步（锁），可以修饰代码块和方法，被修饰的代码块和方法一旦被某个线程访问，则直接锁住，其他的线程将无法访问</li>
<li></li>
<li>同步代码块：</li>
<li>synchronized(锁对象){</li>
<li></li>
<li>}</li>
<li></li>
<li>注意：锁对象需要被所有的线程所共享</li>
<li></li>
<li></li>
<li>同步：安全性高，效率低</li>
<li>非同步：效率高，但是安全性低</li>
<li><p>*/<br>public class TicketThread implements Runnable {<br> int tickets = 100;//火车票数量<br> Object obj = new Object();</p>
<p> @Override<br> public void run() {</p>
<pre><code>//出售火车票
while(true) {
    synchronized (obj) {

        if(tickets &gt; 0) {

            try {
                Thread.sleep(100);
            } catch (InterruptedException e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
            }

            System.out.println(Thread.currentThread().getName() + &quot;:&quot; +tickets--);
        }
    }

}
</code></pre><p> }</p>
</li>
</ul>
<p>}</p>
<p>package com.itheima_04;</p>
<p>public class TicktetTest {<br>    public static void main(String[] args) {<br>        //创建线程对象<br>        TicketThread tt = new TicketThread();</p>
<pre><code>    Thread t = new Thread(tt);
    t.setName(&quot;窗口1&quot;);
    Thread t2 = new Thread(tt);
    t2.setName(&quot;窗口2&quot;);
    Thread t3 = new Thread(tt);
    t3.setName(&quot;窗口3&quot;);

    //启动线程对象
    t.start();
    t2.start();
    t3.start();
}
</code></pre><p>}</p>
<p>3.2.2使用同步方法解决<br> 格式:<br>  修饰符 synchronized 返回值 方法名(){</p>
<p>}<br>3.2.2.1案例代码五:<br>package com.itheima_05;<br>/*</p>
<ul>
<li>同步方法:使用关键字synchronized修饰的方法，一旦被一个线程访问，则整个方法全部锁住，其他线程则无法访问</li>
<li></li>
<li>synchronized</li>
<li>注意：</li>
<li>非静态同步方法的锁对象是this</li>
<li><p>静态的同步方法的锁对象是当前类的字节码对象<br>*/<br>public class TicketThread implements Runnable {<br>static int tickets = 100;// 火车票数量<br>Object obj = new Object();</p>
<p>@Override<br>public void run() {<br>// 出售火车票<br>while (true) {<br> /*synchronized (obj) {</p>
<pre><code>method();
</code></pre><p> }*/</p>
<p> //method();<br> method2();</p>
<p>}<br>}</p>
<p>private synchronized void method() {<br>if (tickets &gt; 0) {</p>
<p> try {</p>
<pre><code>Thread.sleep(100);
</code></pre><p> } catch (InterruptedException e) {</p>
<pre><code>// TODO Auto-generated catch block
e.printStackTrace();
</code></pre><p> }</p>
<p> System.out.println(Thread.currentThread().getName() + “:” + tickets–);<br>}<br>}</p>
</li>
</ul>
<pre><code>private static synchronized void method2() {

    if (tickets &gt; 0) {

        try {
            Thread.sleep(100);
        } catch (InterruptedException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }

        System.out.println(Thread.currentThread().getName() + &quot;:&quot; + tickets--);
    }
}
</code></pre><p>}</p>
<p>package com.itheima_05;</p>
<p>public class TicktetTest {<br>    public static void main(String[] args) {<br>        //创建线程对象<br>        TicketThread tt = new TicketThread();</p>
<pre><code>    Thread t = new Thread(tt);
    t.setName(&quot;窗口1&quot;);
    Thread t2 = new Thread(tt);
    t2.setName(&quot;窗口2&quot;);
    Thread t3 = new Thread(tt);
    t3.setName(&quot;窗口3&quot;);

    //启动线程对象
    t.start();
    t2.start();
    t3.start();
}
</code></pre><p>}</p>
</div><div class="post-copyright"><div class="post-copyright-author"><span class="post-copyright-meta">本文作者: </span><span class="post-copyright-info"><a href="mailto:undefined">shijiaojie</a></span></div><div class="post-copyright-type"><span class="post-copyright-meta">本文链接: </span><span class="post-copyright-info"><a href="http://yoursite.com/2019/05/22/多线程/">http://yoursite.com/2019/05/22/多线程/</a></span></div><div class="post-copyright-notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://yoursite.com">shijj</a>！</span></div></div></article><div id="pagination"><div class="next-post pull-right"><span class="line line-top"></span><span class="line line-right"></span><span class="line line-bottom"></span><span class="line line-left"></span><a href="/2019/05/19/反射/"><span>JAVA - 反射</span><span>&nbsp;</span><i class="fas fa-angle-right"></i></a></div></div><!--div!= paginator()--></div></div><div class="button-hover" id="return-top"><i class="fas fa-arrow-up" aria-hidden="true"></i></div><footer><div id="footer"><div class="button-hover" id="side-button"><i class="fas fa-arrow-right"></i></div><div class="right-content"><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fas fa-file-o"></i></span><span id="busuanzi_value_page_pv"></span><span></span></div><div class="copyright">&copy;2017 ～ 2019 By shijiaojie</div></div></div></footer></div><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/thirdparty/jquery-3.3.1.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/thirdparty/velocity.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/thirdparty/jquery.mCustomScrollbar.concat.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/fan.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/canvas_bg.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/utils.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/scroll.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/sidebar.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/copy.js"></script><!--script(src=url)--></body></html>